direct  := c_p
total_c  := c_p + (a*b)
'
set.seed(230916) #needed for reproducibility especially when specifying bootstrapped confidence intervals
Kim_fit_covs <- lavaan::sem(Kim_fit_covs, data = dfKim, se="bootstrap", missing = 'fiml')
Kcov_sum <- lavaan::summary(Kim_fit_covs, standardized=T, rsq=T, fit=TRUE, ci=TRUE)
Kcov_ParEsts<- lavaan::parameterEstimates(Kim_fit_covs, boot.ci.type = "bca.simple", standardized=TRUE)
Kcov_sum
Kcov_ParEsts
#only worked when I used the library to turn on all these pkgs
library(lavaan)
library(dplyr)
library(ggplot2)
library(tidySEM)
tidySEM::graph_sem(model=Kim_fit_covs)
tidySEM::get_layout(Kim_fit_covs)
med_map3 <- tidySEM::get_layout(
"ANX", "",   "CMI",  "",
"REMS", "",  "",    "PWB", rows=2)
med_map3
tidySEM::graph_sem(Kim_fit_covs, layout=med_map3,  rect_width = 1.5, rect_height = 1.25, spacing_x = 2, spacing_y = 3, text_size = 4.5)
write.csv(Kcov_ParEsts, file = "KimMedCov.csv")
sessionInfo()
Kim_fit_covs <- '
PWB ~ b*CMI + c_p*REMS
CMI ~a*REMS
CMI ~ covM*ANX
PWB ~ covY*ANX
indirect :=  a*b
direct  := c_p
total_c  := c_p + (a*b)
'
set.seed(230916) #needed for reproducibility especially when specifying bootstrapped confidence intervals
Kim_fit_covs <- lavaan::sem(Kim_fit_covs, data = dfKim, se="bootstrap", missing = 'fiml')
Kcov_sum <- lavaan::summary(Kim_fit_covs, standardized=T, rsq=T, fit=TRUE, ci=TRUE)
Kcov_ParEsts<- lavaan::parameterEstimates(Kim_fit_covs, boot.ci.type = "bca.simple", standardized=TRUE)
Kcov_sum
Kcov_ParEsts
options(scipen=999)
#will install the package if not already installed
if(!require(lavaan)){install.packages("lavaan")}
if(!require(tidyverse)){install.packages("tidyverse")}
if(!require(dplyr)){install.packages("dplyr")}
if(!require(psych)){install.packages("psych")}
if(!require(apaTables)){install.packages("apaTables")}
if(!require(tidySEM)){install.packages("tidySEM")}
# Concerned that identical variable names across book chapters may be problematic, I'm adding "p" in front the "Data" variable.
set.seed(230925)
X <- rnorm(100)
M1 <- 0.5*X + rnorm(100)
M2 <- -0.35*X + rnorm(100)
Y <- 0.7*M2 + 0.48*M1 + rnorm(100)
pData <- data.frame(X = X, Y = Y, M1 = M1, M2 = M2)
parallel_med <- '
Y ~ b1*M1 + b2*M2 + c_p*X
M1 ~ a1*X
M2 ~ a2*X
indirect1 := a1 * b1
indirect2 := a2 * b2
contrast := indirect1 - indirect2
total_indirects := indirect1 + indirect2
total_c    := c_p + (indirect1) + (indirect2)
direct := c_p
'
set.seed(230925) #needed for reproducibility especially when specifying bootstrapped confidence intervals
parallel_fit <- lavaan::sem(parallel_med, data = pData, se = "bootstrap", missing = 'fiml', bootstrap = 1000)
pfit_sum <- lavaan::summary(parallel_fit, standardized = TRUE, rsq=T, fit=TRUE, ci=TRUE)
pfit_ParEsts <- lavaan::parameterEstimates(parallel_fit, boot.ci.type = "bca.simple", standardized=TRUE)
pfit_sum
pfit_ParEsts
write.csv(pfit_ParEsts, file = "pfit_ParEsts.csv")
#only worked when I used the library to turn on all these pkgs
library(lavaan)
library(dplyr)
library(ggplot2)
library(tidySEM)
tidySEM::graph_sem(model=parallel_fit)
tidySEM::get_layout(parallel_fit)
parallel_map <- tidySEM::get_layout("", "M1", "",
"X", "", "Y",
"", "M2", "", rows=3)
parallel_map
tidySEM::graph_sem(parallel_fit, layout=parallel_map,  rect_width = 1.5, rect_height = 1.25, spacing_x = 2, spacing_y = 3, text_size = 4.5)
#Entering the intercorrelations, means, and standard deviations from the journal article
Lewis_generating_model <- '
##measurement model
GRMS  =~ .69*Ob1 + .69*Ob2 + .60*Ob3 + .59*Ob4 + .55*Ob5 + .55*Ob6 + .54*Ob7 + .50*Ob8 + .41*Ob9 + .41*Ob10 + .93*Ma1 + .81*Ma2 + .69*Ma3 + .67*Ma4 + .61*Ma5 + .58*Ma6 + .54*Ma7 + .59*St1 + .55*St2 + .54*St3 + .54*St4 + .51*St5 + .70*An1 + .69*An2 + .68*An3
MntlHlth  =~ .8*MH1 + .8*MH2 + .8*MH3 + .8*MH4 + .8*MH5 + .8*MH6
PhysHlth  =~ .8*PhH1 + .8*PhH2 + .8*PhH3 + .8*PhH4 + .8*PhH5 + .8*PhH6
Spirituality  =~ .8*Spirit1 + .8*Spirit2
SocSupport  =~ .8*SocS1 + .8*SocS2
Engagement  =~ .8*Eng1 + .8*Eng2
Disengagement  =~  .8*dEng1 + .8*dEng2
GRIC  =~ .8*Cntrlty1 + .8*Cntrlty2 + .8*Cntrlty3 + .8*Cntrlty4 + .8*Cntrlty5 + .8*Cntrlty6 + .8*Cntrlty7 + .8*Cntrlty8 + .8*Cntrlty9 + .8*Cntrlty10
# Means
GRMS ~ 1.99*1
Spirituality ~2.82*1
SocSupport ~ 2.48*1
Engagement ~ 2.32*1
Disengagement ~ 1.75*1
GRIC ~ 5.71*1
MntlHlth ~3.56*1 #Lewis et al used sums instead of means, I recast as means to facilitate simulation
PhysHlth ~ 3.51*1 #Lewis et al used sums instead of means, I recast as means to facilitate simulation
# Correlations (ha!)
GRMS ~ 0.20*Spirituality
GRMS ~ 0.28*SocSupport
GRMS ~ 0.30*Engagement
GRMS ~ 0.41*Disengagement
GRMS ~ 0.19*GRIC
GRMS ~ -0.32*MntlHlth
GRMS ~ -0.18*PhysHlth
Spirituality ~ 0.49*SocSupport
Spirituality ~ 0.57*Engagement
Spirituality ~ 0.22*Disengagement
Spirituality ~ 0.12*GRIC
Spirituality ~ -0.06*MntlHlth
Spirituality ~ -0.13*PhysHlth
SocSupport ~ 0.46*Engagement
SocSupport ~ 0.26*Disengagement
SocSupport ~ 0.38*GRIC
SocSupport ~ -0.18*MntlHlth
SocSupport ~ -0.08*PhysHlth
Engagement ~ 0.37*Disengagement
Engagement ~ 0.08*GRIC
Engagement ~ -0.14*MntlHlth
Engagement ~ -0.06*PhysHlth
Disengagement ~ 0.05*GRIC
Disengagement ~ -0.54*MntlHlth
Disengagement ~ -0.28*PhysHlth
GRIC ~ -0.10*MntlHlth
GRIC ~ 0.14*PhysHlth
MntlHlth ~ 0.47*PhysHlth
'
set.seed(230925)
dfLewis <- lavaan::simulateData(model = Lewis_generating_model,
model.type = "sem",
meanstructure = T,
sample.nobs=231,
standardized=FALSE)
#used to retrieve column indices used in the rescaling script below
#col_index <- as.data.frame(colnames(dfLewis))
for(i in 1:ncol(dfLewis)){  # for loop to go through each column of the dataframe
if(i >= 1 & i <= 25){   # apply only to GRMS variables
dfLewis[,i] <- scales::rescale(dfLewis[,i], c(0, 5))
}
if(i >= 26 & i <= 37){   # apply only to mental and physical health variables
dfLewis[,i] <- scales::rescale(dfLewis[,i], c(0, 6))
}
if(i >= 38 & i <= 45){   # apply only to coping variables
dfLewis[,i] <- scales::rescale(dfLewis[,i], c(1, 4))
}
if(i >= 46 & i <= 55){   # apply only to GRIC variables
dfLewis[,i] <- scales::rescale(dfLewis[,i], c(1, 7))
}
}
#rounding to integers so that the data resembles that which was collected
library(tidyverse)
dfLewis <- dfLewis %>% round(0)
#quick check of my work
#psych::describe(dfLewis)
#saveRDS(dfLewis, 'dfLewis.rds')
#dfLewis<- readRDS('dfLewis.rds')
#write.table(dfLewis, file = 'dfLewis.csv', sep = ',', col.names=TRUE, row.names=FALSE)
#dfLewis<- read.csv ('dfLewis.csv', header = TRUE)
GRMS_vars <- c("Ob1", "Ob2", "Ob3", "Ob4", "Ob5", "Ob6", "Ob7", "Ob8", "Ob9", "Ob10", "Ma1", "Ma2", "Ma3", "Ma4", "Ma5", "Ma6", "Ma7", "St1", "St2", "St3", "St4", "St5", "An1", "An2", "An3")
Eng_vars <- c("Eng1", "Eng2")
dEng_vars <- c("dEng1", "dEng2")
MntlHlth_vars <- c("MH1", "MH2", "MH3", "MH4", "MH5", "MH6")
dfLewis$GRMS <- sjstats::mean_n(dfLewis[, GRMS_vars], 0.80)
dfLewis$Engmt <- sjstats::mean_n(dfLewis[, Eng_vars], 0.80)
dfLewis$DisEngmt <- sjstats::mean_n(dfLewis[, dEng_vars], 0.80)
dfLewis$MntlHlth <- sjstats::mean_n(dfLewis[, MntlHlth_vars], 0.80)
Lewis_df <- dplyr::select(dfLewis, GRMS, Engmt, DisEngmt, MntlHlth)
Lewis_table <- apaTables::apa.cor.table(Lewis_df, table.number = 1, show.sig.stars=TRUE, landscape=TRUE, filename="Lewis_Corr.doc")
print(Lewis_table)
parallel_Lewis <- '
MntlHlth ~ b1*Engmt + b2*DisEngmt + c_p*GRMS
Engmt ~ a1*GRMS
DisEngmt ~ a2*GRMS
indirect1 := a1 * b1
indirect2 := a2 * b2
contrast := indirect1 - indirect2
total_indirects := indirect1 + indirect2
total_c := c_p + (indirect1) + (indirect2)
direct := c_p
'
para_Lewis_fit <- lavaan::sem(parallel_Lewis, data = Lewis_df, se = "bootstrap", bootstrap = 1000, missing = 'fiml') #holds the "whole" result
pLewis_sum <- lavaan::summary(para_Lewis_fit , standardized = TRUE, rsq=T, fit=TRUE, ci=TRUE) #today, we really only need the R-squared from here
pLewis_ParEsts <- lavaan::parameterEstimates(para_Lewis_fit, boot.ci.type = "bca.simple", standardized=TRUE) #provides our estimates, se, p values for all the elements we specified
pLewis_sum
pLewis_ParEsts
write.csv(pLewis_ParEsts, file = "pLewis_ParEsts.csv")
#only worked when I used the library to turn on all these pkgs
library(lavaan)
library(dplyr)
library(ggplot2)
library(tidySEM)
tidySEM::graph_sem(model=para_Lewis_fit)
tidySEM::get_layout(para_Lewis_fit)
pLewis_map <- tidySEM::get_layout("", "Engmt", "",
"GRMS", "", "MntlHlth",
"", "DisEngmt", "", rows=3)
pLewis_map
tidySEM::graph_sem(para_Lewis_fit, layout=pLewis_map,  rect_width = 1.5, rect_height = 1.25, spacing_x = 2, spacing_y = 3, text_size = 4.5)
serial_Lewis <- '
MntlHlth ~ b1*Engmt + b2*DisEngmt + c_p*GRMS
Engmt ~ a1*GRMS
DisEngmt ~ a2*GRMS
DisEngmt ~ d21*Engmt
indirect1 := a1 * b1
indirect2 := a2 * b2
indirect3 := a1 * d21 * b2
contrast1 := indirect1 - indirect2
contrast2 := indirect1 - indirect3
contrast3 := indirect2 - indirect3
total_indirects := indirect1 + indirect2 + indirect3
total_c := c_p + indirect1 + indirect2 + indirect3
direct := c_p
'
serial_Lewis_fit <- lavaan::sem(serial_Lewis, data = Lewis_df, se = "bootstrap", missing = 'fiml', bootstrap = 1000)
sLewis_sum <- lavaan::summary(serial_Lewis_fit, standardized = TRUE, rsq=T, fit=TRUE, ci=TRUE)
sLewis_ParEsts <- lavaan::parameterEstimates(serial_Lewis_fit, boot.ci.type = "bca.simple", standardized=TRUE)
sLewis_sum
sLewis_ParEsts
write.csv(sLewis_ParEsts, file = "sLewis_ParEsts.csv")
#only worked when I used the library to turn on all these pkgs
library(lavaan)
library(dplyr)
library(ggplot2)
library(tidySEM)
tidySEM::graph_sem(model=serial_Lewis_fit)
tidySEM::get_layout(serial_Lewis_fit)
sLewis_map <- tidySEM::get_layout("", "Engmt", "",
"GRMS", "", "MntlHlth",
"", "DisEngmt", "", rows=3)
sLewis_map
tidySEM::graph_sem(serial_Lewis_fit, layout=sLewis_map,  rect_width = 1.5, rect_height = 1.25, spacing_x = 2, spacing_y = 3, text_size = 4.5)
sessionInfo()
options(scipen=999)
#will install the package if not already installed
if(!require(lavaan)){install.packages("lavaan")}
if(!require(tidyverse)){install.packages("tidyverse")}
if(!require(dplyr)){install.packages("dplyr")}
if(!require(psych)){install.packages("psych")}
if(!require(apaTables)){install.packages("apaTables")}
if(!require(tidySEM)){install.packages("tidySEM")}
# Concerned that identical variable names across book chapters may be problematic, I'm adding "p" in front the "Data" variable.
set.seed(230925)
X <- rnorm(100)
M1 <- 0.5*X + rnorm(100)
M2 <- -0.35*X + rnorm(100)
Y <- 0.7*M2 + 0.48*M1 + rnorm(100)
pData <- data.frame(X = X, Y = Y, M1 = M1, M2 = M2)
parallel_med <- '
Y ~ b1*M1 + b2*M2 + c_p*X
M1 ~ a1*X
M2 ~ a2*X
indirect1 := a1 * b1
indirect2 := a2 * b2
contrast := indirect1 - indirect2
total_indirects := indirect1 + indirect2
total_c    := c_p + (indirect1) + (indirect2)
direct := c_p
'
set.seed(230925) #needed for reproducibility especially when specifying bootstrapped confidence intervals
parallel_fit <- lavaan::sem(parallel_med, data = pData, se = "bootstrap", missing = 'fiml', bootstrap = 1000)
pfit_sum <- lavaan::summary(parallel_fit, standardized = TRUE, rsq=T, fit=TRUE, ci=TRUE)
pfit_ParEsts <- lavaan::parameterEstimates(parallel_fit, boot.ci.type = "bca.simple", standardized=TRUE)
pfit_sum
pfit_ParEsts
write.csv(pfit_ParEsts, file = "pfit_ParEsts.csv")
#only worked when I used the library to turn on all these pkgs
library(lavaan)
library(dplyr)
library(ggplot2)
library(tidySEM)
tidySEM::graph_sem(model=parallel_fit)
tidySEM::get_layout(parallel_fit)
parallel_map <- tidySEM::get_layout("", "M1", "",
"X", "", "Y",
"", "M2", "", rows=3)
parallel_map
tidySEM::graph_sem(parallel_fit, layout=parallel_map,  rect_width = 1.5, rect_height = 1.25, spacing_x = 2, spacing_y = 3, text_size = 4.5)
#Entering the intercorrelations, means, and standard deviations from the journal article
Lewis_generating_model <- '
##measurement model
GRMS  =~ .69*Ob1 + .69*Ob2 + .60*Ob3 + .59*Ob4 + .55*Ob5 + .55*Ob6 + .54*Ob7 + .50*Ob8 + .41*Ob9 + .41*Ob10 + .93*Ma1 + .81*Ma2 + .69*Ma3 + .67*Ma4 + .61*Ma5 + .58*Ma6 + .54*Ma7 + .59*St1 + .55*St2 + .54*St3 + .54*St4 + .51*St5 + .70*An1 + .69*An2 + .68*An3
MntlHlth  =~ .8*MH1 + .8*MH2 + .8*MH3 + .8*MH4 + .8*MH5 + .8*MH6
PhysHlth  =~ .8*PhH1 + .8*PhH2 + .8*PhH3 + .8*PhH4 + .8*PhH5 + .8*PhH6
Spirituality  =~ .8*Spirit1 + .8*Spirit2
SocSupport  =~ .8*SocS1 + .8*SocS2
Engagement  =~ .8*Eng1 + .8*Eng2
Disengagement  =~  .8*dEng1 + .8*dEng2
GRIC  =~ .8*Cntrlty1 + .8*Cntrlty2 + .8*Cntrlty3 + .8*Cntrlty4 + .8*Cntrlty5 + .8*Cntrlty6 + .8*Cntrlty7 + .8*Cntrlty8 + .8*Cntrlty9 + .8*Cntrlty10
# Means
GRMS ~ 1.99*1
Spirituality ~2.82*1
SocSupport ~ 2.48*1
Engagement ~ 2.32*1
Disengagement ~ 1.75*1
GRIC ~ 5.71*1
MntlHlth ~3.56*1 #Lewis et al used sums instead of means, I recast as means to facilitate simulation
PhysHlth ~ 3.51*1 #Lewis et al used sums instead of means, I recast as means to facilitate simulation
# Correlations (ha!)
GRMS ~ 0.20*Spirituality
GRMS ~ 0.28*SocSupport
GRMS ~ 0.30*Engagement
GRMS ~ 0.41*Disengagement
GRMS ~ 0.19*GRIC
GRMS ~ -0.32*MntlHlth
GRMS ~ -0.18*PhysHlth
Spirituality ~ 0.49*SocSupport
Spirituality ~ 0.57*Engagement
Spirituality ~ 0.22*Disengagement
Spirituality ~ 0.12*GRIC
Spirituality ~ -0.06*MntlHlth
Spirituality ~ -0.13*PhysHlth
SocSupport ~ 0.46*Engagement
SocSupport ~ 0.26*Disengagement
SocSupport ~ 0.38*GRIC
SocSupport ~ -0.18*MntlHlth
SocSupport ~ -0.08*PhysHlth
Engagement ~ 0.37*Disengagement
Engagement ~ 0.08*GRIC
Engagement ~ -0.14*MntlHlth
Engagement ~ -0.06*PhysHlth
Disengagement ~ 0.05*GRIC
Disengagement ~ -0.54*MntlHlth
Disengagement ~ -0.28*PhysHlth
GRIC ~ -0.10*MntlHlth
GRIC ~ 0.14*PhysHlth
MntlHlth ~ 0.47*PhysHlth
'
set.seed(230925)
dfLewis <- lavaan::simulateData(model = Lewis_generating_model,
model.type = "sem",
meanstructure = T,
sample.nobs=231,
standardized=FALSE)
#used to retrieve column indices used in the rescaling script below
#col_index <- as.data.frame(colnames(dfLewis))
for(i in 1:ncol(dfLewis)){  # for loop to go through each column of the dataframe
if(i >= 1 & i <= 25){   # apply only to GRMS variables
dfLewis[,i] <- scales::rescale(dfLewis[,i], c(0, 5))
}
if(i >= 26 & i <= 37){   # apply only to mental and physical health variables
dfLewis[,i] <- scales::rescale(dfLewis[,i], c(0, 6))
}
if(i >= 38 & i <= 45){   # apply only to coping variables
dfLewis[,i] <- scales::rescale(dfLewis[,i], c(1, 4))
}
if(i >= 46 & i <= 55){   # apply only to GRIC variables
dfLewis[,i] <- scales::rescale(dfLewis[,i], c(1, 7))
}
}
#rounding to integers so that the data resembles that which was collected
library(tidyverse)
dfLewis <- dfLewis %>% round(0)
#quick check of my work
#psych::describe(dfLewis)
#saveRDS(dfLewis, 'dfLewis.rds')
#dfLewis<- readRDS('dfLewis.rds')
#write.table(dfLewis, file = 'dfLewis.csv', sep = ',', col.names=TRUE, row.names=FALSE)
#dfLewis<- read.csv ('dfLewis.csv', header = TRUE)
GRMS_vars <- c("Ob1", "Ob2", "Ob3", "Ob4", "Ob5", "Ob6", "Ob7", "Ob8", "Ob9", "Ob10", "Ma1", "Ma2", "Ma3", "Ma4", "Ma5", "Ma6", "Ma7", "St1", "St2", "St3", "St4", "St5", "An1", "An2", "An3")
Eng_vars <- c("Eng1", "Eng2")
dEng_vars <- c("dEng1", "dEng2")
MntlHlth_vars <- c("MH1", "MH2", "MH3", "MH4", "MH5", "MH6")
dfLewis$GRMS <- sjstats::mean_n(dfLewis[, GRMS_vars], 0.80)
dfLewis$Engmt <- sjstats::mean_n(dfLewis[, Eng_vars], 0.80)
dfLewis$DisEngmt <- sjstats::mean_n(dfLewis[, dEng_vars], 0.80)
dfLewis$MntlHlth <- sjstats::mean_n(dfLewis[, MntlHlth_vars], 0.80)
Lewis_df <- dplyr::select(dfLewis, GRMS, Engmt, DisEngmt, MntlHlth)
Lewis_table <- apaTables::apa.cor.table(Lewis_df, table.number = 1, show.sig.stars=TRUE, landscape=TRUE, filename="Lewis_Corr.doc")
print(Lewis_table)
parallel_Lewis <- '
MntlHlth ~ b1*Engmt + b2*DisEngmt + c_p*GRMS
Engmt ~ a1*GRMS
DisEngmt ~ a2*GRMS
indirect1 := a1 * b1
indirect2 := a2 * b2
contrast := indirect1 - indirect2
total_indirects := indirect1 + indirect2
total_c := c_p + (indirect1) + (indirect2)
direct := c_p
'
set.seed(230925)#necessary for reproducible results because lavaan introduces randomness into the estimation process
para_Lewis_fit <- lavaan::sem(parallel_Lewis, data = Lewis_df, se = "bootstrap", bootstrap = 1000, missing = 'fiml') #holds the "whole" result
pLewis_sum <- lavaan::summary(para_Lewis_fit , standardized = TRUE, rsq=T, fit=TRUE, ci=TRUE) #today, we really only need the R-squared from here
pLewis_ParEsts <- lavaan::parameterEstimates(para_Lewis_fit, boot.ci.type = "bca.simple", standardized=TRUE) #provides our estimates, se, p values for all the elements we specified
pLewis_sum
pLewis_ParEsts
write.csv(pLewis_ParEsts, file = "pLewis_ParEsts.csv")
#only worked when I used the library to turn on all these pkgs
library(lavaan)
library(dplyr)
library(ggplot2)
library(tidySEM)
tidySEM::graph_sem(model=para_Lewis_fit)
tidySEM::get_layout(para_Lewis_fit)
pLewis_map <- tidySEM::get_layout("", "Engmt", "",
"GRMS", "", "MntlHlth",
"", "DisEngmt", "", rows=3)
pLewis_map
tidySEM::graph_sem(para_Lewis_fit, layout=pLewis_map,  rect_width = 1.5, rect_height = 1.25, spacing_x = 2, spacing_y = 3, text_size = 4.5)
serial_Lewis <- '
MntlHlth ~ b1*Engmt + b2*DisEngmt + c_p*GRMS
Engmt ~ a1*GRMS
DisEngmt ~ a2*GRMS
DisEngmt ~ d21*Engmt
indirect1 := a1 * b1
indirect2 := a2 * b2
indirect3 := a1 * d21 * b2
contrast1 := indirect1 - indirect2
contrast2 := indirect1 - indirect3
contrast3 := indirect2 - indirect3
total_indirects := indirect1 + indirect2 + indirect3
total_c := c_p + indirect1 + indirect2 + indirect3
direct := c_p
'
set.seed(230925)#necessary for reproducible results because lavaan introduces randomness into the estimation process
serial_Lewis_fit <- lavaan::sem(serial_Lewis, data = Lewis_df, se = "bootstrap", missing = 'fiml', bootstrap = 1000)
sLewis_sum <- lavaan::summary(serial_Lewis_fit, standardized = TRUE, rsq=T, fit=TRUE, ci=TRUE)
sLewis_ParEsts <- lavaan::parameterEstimates(serial_Lewis_fit, boot.ci.type = "bca.simple", standardized=TRUE)
sLewis_sum
sLewis_ParEsts
write.csv(sLewis_ParEsts, file = "sLewis_ParEsts.csv")
#only worked when I used the library to turn on all these pkgs
library(lavaan)
library(dplyr)
library(ggplot2)
library(tidySEM)
tidySEM::graph_sem(model=serial_Lewis_fit)
tidySEM::get_layout(serial_Lewis_fit)
sLewis_map <- tidySEM::get_layout("", "Engmt", "",
"GRMS", "", "MntlHlth",
"", "DisEngmt", "", rows=3)
sLewis_map
tidySEM::graph_sem(serial_Lewis_fit, layout=sLewis_map,  rect_width = 1.5, rect_height = 1.25, spacing_x = 2, spacing_y = 3, text_size = 4.5)
sessionInfo()
options(scipen=999)
#pick one format (.rds) or the other (.csv)
raw <- readRDS("MADdf230912.rds")
#raw<- read.csv("MADdf230912.csv", header=TRUE)
nrow(raw)
library(tidyverse)
raw <- dplyr::filter (raw, DistributionChannel != "preview")
raw <-(dplyr::filter(raw, Wave == 1))
StigmaFelt_vars <- c('FMreactions_1', 'FMreactions_2','FMreactions_3','FMreactions_4','FMreactions_5','FMreactions_6')
raw$StigmaFelt <- sjstats::mean_n(raw[, StigmaFelt_vars], .65)
raw<- raw %>%
mutate(PANAS_3r = 6 - PANAS_3)%>%
mutate(PANAS_4r = 6 - PANAS_4)%>%
mutate(PANAS_7r = 6 - PANAS_7)%>%
mutate(PANAS_8r = 6 - PANAS_8)%>%
mutate(PANAS_9r = 6 - PANAS_9)
PANAS_vars <- c('PANAS_1', 'PANAS_2','PANAS_3r','PANAS_4r','PANAS_5','PANAS_6','PANAS_7r','PANAS_8r','PANAS_9r','PANAS_10')
raw$PANAS <-sjstats::mean_n(raw[, PANAS_vars], .80)
babydf <- dplyr::select(raw, cases, PANAS, StigmaFelt, myPropFM_1)
options(scipen=999)
#pick one format (.rds) or the other (.csv)
raw <- readRDS("MADdf231001.rds")
#raw<- read.csv("MADdf231001.csv", header=TRUE)
nrow(raw)
library(tidyverse)
raw <- dplyr::filter (raw, DistributionChannel != "preview")
raw <-(dplyr::filter(raw, Wave == 1))
StigmaFelt_vars <- c('FMreactions_1', 'FMreactions_2','FMreactions_3','FMreactions_4','FMreactions_5','FMreactions_6')
raw$ReceivedStigma <- sjstats::mean_n(raw[, StigmaFelt_vars], .75)
#Must reverse-score ExprStig_2
library(tidyverse)
raw <- raw %>%
dplyr::mutate(rExprStig_2 = 6 - ExprStig_2)
ExprStig_vars <- c('ExprStig_1', 'rExprStig_2','ExprStig_3','ExprStig_4')
raw$ExpressedStigma <- sjstats::mean_n(raw[, ExprStig_vars], .75)
raw <- dplyr::rename(raw, OwnWear = "myPropFM_1", OthersWear = "OthersProp_1", FutureWear = "FutureWear_2")
babydf <- dplyr::select(raw, mcases, OthersWear,OwnWear, FutureWear, ReceivedStigma, ExpressedStigma, )
str(babydf)
set.seed(231005)
complex_mask <- '
FutureWear ~ b*OwnWear + c_p1*ExpressedStigma + c_p2*ReceivedStigma + cov*mcases
OwnWear ~ a1*ExpressedStigma
OwnWear ~ a2*ReceivedStigma
indirect1 := a1 * b
indirect2 := a2 * b
contrast1 := indirect1 - indirect2
total_indirects := indirect1 + indirect2
total_c := c_p1 + c_p2 + indirect1 + indirect2
direct1 := c_p1
direct2 := c_p2
'
set.seed(231002)#needed for reproducible results because lavaan introduces some level of randomness in its estimation procedures
complex_mask_fit <- lavaan::sem(complex_mask, data = babydf, se = "bootstrap", missing = 'fiml', bootstrap = 1000)
cMask_sum <- lavaan::summary(complex_mask_fit, standardized = TRUE, rsq=T, fit=TRUE, ci=TRUE)
cMask_ParEsts <- lavaan::parameterEstimates(complex_mask_fit, boot.ci.type = "bca.simple", standardized=TRUE)
cMask_sum
cMask_ParEsts
lavaan::lavInspect(complex_mask_fit, "rsquare")
#only worked when I used the library to turn on all these pkgs
library(lavaan)
library(dplyr)
library(ggplot2)
library(tidySEM)
tidySEM::graph_sem(model=complex_mask_fit)
tidySEM::get_layout(complex_mask_fit)
complex_mask_map <- tidySEM::get_layout("ExpressedStigma", "", "",
"", "OwnWear", "FutureWear",
"ReceivedStigma", "", "",
"", "mcases", "", rows=4)
complex_mask_map
tidySEM::graph_sem(complex_mask_fit, layout=complex_mask_map,  rect_width =3, rect_height = 7, spacing_x = 5, spacing_y = 15, text_size = 4)
write.csv(cMask_ParEsts, file = "cMask_ParEsts.csv")
