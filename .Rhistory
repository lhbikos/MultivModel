#Kim_struct_pEsts #although creating the object is useful to export as a .csv I didn't ask it to print into the book
#global fit indices
Kim_struct_fitstats <- tidySEM::table_fit(Kim_struct_fit)
write.csv(Kim_struct_fitstats, file = "Kim_struct_fitstats.csv")
#the code below writes the parameter estimates into a .csv file
write.csv(Kim_struct_pEsts, file = "Kim_struct_pEsts.csv")
plot_Kim_struct <- semPlot::semPaths(Kim_struct_fit, what = "col", whatLabels = "stand", sizeMan = 5, node.width = 1, edge.label.cex = .75, style = "lisrel", mar = c(5,5,5,5))
plot_Kim_struct <- semPlot::semPaths(Kim_struct_fit, what = "col", whatLabels = "stand", sizeMan = 5, node.width = 1, edge.label.cex = .75, style = "lisrel", mar = c(5,5,5,5))
#IMPORTANT:  Must use the node names (take directly from the SemPlot) assigned by SemPlot
#You can change them as the last thing
m1_msmt <- semptools::layout_matrix(REM = c(2,1),
CMI = c(1,2),
PWB = c(2,3))
#tell where you want the indicators to face
m1_point_to <- semptools::layout_matrix (left = c(2,1),
up = c(1,2),
right = c(2,3))
#the next two codes -- indicator_order and indicator_factor are paired together, they specify the order of observed variables for each factor
m1_indicator_order <- c("p1R", "p2R", "p3R",
"p1C", "p2C", "p3C",
"p1P", "p2P", "p3P")
m1_indicator_factor <- c("REM", "REM", "REM",
"CMI", "CMI", "CMI",
"PWB", "PWB", "PWB")
#next set of code pushes the indicator variables away from the factor
m1_indicator_push <- c(REM = .5,
CMI = 1,
PWB = 1)
m1_indicator_spread <- c(REM = 1, #spreading the boxes away from each other
CMI = 1,
PWB = 1)
plot1 <- semptools::set_sem_layout(plot_Kim_struct,
indicator_order = m1_indicator_order,
indicator_factor = m1_indicator_factor,
factor_layout = m1_msmt,
factor_point_to = m1_point_to,
indicator_push = m1_indicator_push,
indicator_spread = m1_indicator_spread)
#changing node labels
plot1 <- semptools::change_node_label(plot1,
c(REM = "mAggress",
CMI = "cMistrust",
PWB = "Wellbeing"),
label.cex = 1.1)
plot(plot1)
#Code to plot the theoretical model (in case you don't want to print the results on the graph):
p_theoretical <- semPlot::semPaths(Kim_struct_fit)
p_theoretical <- semptools::set_sem_layout(p_theoretical,
indicator_order = m1_indicator_order,
indicator_factor = m1_indicator_factor,
factor_layout = m1_msmt,
factor_point_to = m1_point_to,
indicator_push = m1_indicator_push,
indicator_spread = m1_indicator_spread)
plot(p_theoretical)
#Code to plot the theoretical model (in case you don't want to print the results on the graph):
p_theoretical <- semPlot::semPaths(Kim_struct_fit)
p_theoretical <- semptools::set_sem_layout(p_theoretical,
indicator_order = m1_indicator_order,
indicator_factor = m1_indicator_factor,
factor_layout = m1_msmt,
factor_point_to = m1_point_to,
indicator_push = m1_indicator_push,
indicator_spread = m1_indicator_spread)
plot(p_theoretical)
Kim_swap_mod <- "
##measurement model
REMS =~ p1REMS + p2REMS + p3REMS
CMI =~ p1CMI + p2CMI + p3CMI
PWB =~ p1PWB + p2PWB + p3PWB
#structural model with labels for calculation of the indirect effect
CMI ~ b*PWB + c_p*REMS
PWB ~a*REMS
#calculations
indirect :=  a*b
direct  := c_p
total_c  := c_p + (a*b)
"
set.seed(230916) #needed for reproducibility especially when specifying bootstrapped confidence intervals
Kim_swap_fit <- lavaan::sem(Kim_swap_mod, data = dfKim, missing= 'fiml')
Kim_swap_summary <- lavaan::summary(Kim_swap_fit, fit.measures=TRUE, standardized=TRUE, rsq = TRUE)
Kim_swap_pEsts <- lavaan::parameterEstimates(Kim_swap_fit, boot.ci.type = "bca.simple", standardized=TRUE)
Kim_swap_summary
#Kim_swap_pEsts #although creating the object is useful to export as a .csv I didn't ask it to print into the book
#global fit indices
Kim_swap_fitstats <- tidySEM::table_fit(Kim_swap_fit)
write.csv(Kim_swap_fitstats, file = "Kim_swap_fitstats.csv")
#the code below writes the parameter estimates into a .csv file
write.csv(Kim_swap_pEsts, file = "Kim_swap_pEsts.csv")
plot_Kim_swap <- semPlot::semPaths(Kim_swap_fit, what = "col", whatLabels = "stand", sizeMan = 5, node.width = 1, edge.label.cex = .75, style = "lisrel", mar = c(5,5,5,5))
plot_Kim_swap <- semPlot::semPaths(Kim_swap_fit, what = "col", whatLabels = "stand", sizeMan = 5, node.width = 1, edge.label.cex = .75, style = "lisrel", mar = c(5,5,5,5))
#IMPORTANT:  Must use the node names (take directly from the SemPlot) assigned by SemPlot
#You can change them as the last thing
m2_msmt <- semptools::layout_matrix(REM = c(2,1),
CMI = c(2,3),
PWB = c(1,2))
#tell where you want the indicators to face
m2_point_to <- semptools::layout_matrix (left = c(2,1),
up = c(1,2),
right = c(2,3))
#the next two codes -- indicator_order and indicator_factor are paired together, they specify the order of observed variables for each factor
m2_indicator_order <- c("p1R", "p2R", "p3R",
"p1C", "p2C", "p3C",
"p1P", "p2P", "p3P")
m2_indicator_factor <- c("REM", "REM", "REM",
"CMI", "CMI", "CMI",
"PWB", "PWB", "PWB")
#next set of code pushes the indicator variables away from the factor
m2_indicator_push <- c(REM = .5,
CMI = 1,
PWB = 1)
m2_indicator_spread <- c(REM = 1, #spreading the boxes away from each other
CMI = 1,
PWB = 1)
#assemble all the instructions
plot2 <- semptools::set_sem_layout(plot_Kim_swap,
indicator_order = m2_indicator_order,
indicator_factor = m2_indicator_factor,
factor_layout = m2_msmt,
factor_point_to = m2_point_to,
indicator_push = m2_indicator_push,
indicator_spread = m2_indicator_spread)
#changing node labels
plot2 <- semptools::change_node_label(plot2,
c(REM = "mAggress",
CMI = "cMistrust",
PWB = "Wellbeing"),
label.cex = 1.1)
plot(plot2)
#IMPORTANT:  Must use the node names (take directly from the SemPlot) assigned by SemPlot
#You can change them as the last thing
m2_msmt <- semptools::layout_matrix(REM = c(2,1),
CMI = c(2,3),
PWB = c(1,2))
#tell where you want the indicators to face
m2_point_to <- semptools::layout_matrix (left = c(2,1),
up = c(1,2),
right = c(2,3))
#the next two codes -- indicator_order and indicator_factor are paired together, they specify the order of observed variables for each factor
m2_indicator_order <- c("p1R", "p2R", "p3R",
"p1C", "p2C", "p3C",
"p1P", "p2P", "p3P")
m2_indicator_factor <- c("REM", "REM", "REM",
"CMI", "CMI", "CMI",
"PWB", "PWB", "PWB")
#next set of code pushes the indicator variables away from the factor
m2_indicator_push <- c(REM = .5,
CMI = 1,
PWB = 1)
m2_indicator_spread <- c(REM = 1, #spreading the boxes away from each other
CMI = 1,
PWB = 1)
#assemble all the instructions
plot2 <- semptools::set_sem_layout(plot_Kim_swap,
indicator_order = m2_indicator_order,
indicator_factor = m2_indicator_factor,
factor_layout = m2_msmt,
factor_point_to = m2_point_to,
indicator_push = m2_indicator_push,
indicator_spread = m2_indicator_spread)
#changing node labels
plot2 <- semptools::change_node_label(plot2,
c(REM = "mAggress",
CMI = "cMistrust",
PWB = "Wellbeing"),
label.cex = 1.1)
plot(plot2)
#Code to plot the theoretical model (in case you don't want to print the results on the graph):
p2_theoretical <- semPlot::semPaths(Kim_swap_fit)
p2_theoretical <- semptools::set_sem_layout(p2_theoretical,
indicator_order = m2_indicator_order,
indicator_factor = m2_indicator_factor,
factor_layout = m2_msmt,
factor_point_to = m2_point_to,
indicator_push = m2_indicator_push,
indicator_spread = m2_indicator_spread)
plot(p2_theoretical)
Kim_2dvs_mod <- "
##measurement model
REMS =~ p1REMS + p2REMS + p3REMS
CMI =~ p1CMI + p2CMI + p3CMI
PWB =~ p1PWB + p2PWB + p3PWB
#structural model with labels for calculation of the indirect effect
CMI ~ REMS
PWB ~ REMS
CMI ~~ 0*PWB
"
set.seed(230916) #needed for reproducibility especially when specifying bootstrapped confidence intervals
Kim_2dvs_fit <- lavaan::sem(Kim_2dvs_mod, data = dfKim, missing= 'fiml', fixed.x = FALSE)
Kim_2dvs_summary <- lavaan::summary(Kim_2dvs_fit, fit.measures=TRUE, standardized=TRUE, rsq = TRUE)
Kim_2dvs_pEsts <- lavaan::parameterEstimates(Kim_2dvs_fit, boot.ci.type = "bca.simple", standardized=TRUE)
Kim_2dvs_summary
#Kim_2dvs_pEsts#although creating the object is useful to export as a .csv I didn't ask it to print into the book
#global fit indices
Kim_2dvs_fitstats <- tidySEM::table_fit(Kim_2dvs_fit)
write.csv(Kim_2dvs_fitstats, file = "Kim_2dvs_fitstats.csv")
#the code below writes the parameter estimates into a .csv file
write.csv(Kim_2dvs_pEsts, file = "Kim_2dvs_pEsts.csv")
plot_Kim_2dvs <- semPlot::semPaths(Kim_2dvs_fit, what = "col", whatLabels = "stand", sizeMan = 5, node.width = 1, edge.label.cex = .75, style = "lisrel", mar = c(5,5,5,5))
#IMPORTANT:  Must use the node names (take directly from the SemPlot) assigned by SemPlot
#You can change them as the last thing
m3_msmt <- semptools::layout_matrix(REM = c(2,1),
CMI = c(1,2),
PWB = c(3,2))
#tell where you want the indicators to face
m3_point_to <- semptools::layout_matrix (left = c(2,1),
right = c(1,2),
right = c(3,2))
#the next two codes -- indicator_order and indicator_factor are paired together, they specify the order of observed variables for each factor
m3_indicator_order <- c("p1R", "p2R", "p3R",
"p1C", "p2C", "p3C",
"p1P", "p2P", "p3P")
m3_indicator_factor <- c("REM", "REM", "REM",
"CMI", "CMI", "CMI",
"PWB", "PWB", "PWB")
#next set of code pushes the indicator variables away from the factor
m3_indicator_push <- c(REM = .5,
CMI = 1,
PWB = 1)
m3_indicator_spread <- c(REM = 1, #spreading the boxes away from each other
CMI = 1,
PWB = 1)
#assemble all the instructions
plot3 <- semptools::set_sem_layout(plot_Kim_2dvs,
indicator_order = m3_indicator_order,
indicator_factor = m3_indicator_factor,
factor_layout = m3_msmt,
factor_point_to = m3_point_to,
indicator_push = m3_indicator_push,
indicator_spread = m3_indicator_spread)
#changing node labels
plot3 <- semptools::change_node_label(plot3,
c(REM = "mAggress",
CMI = "cMistrust",
PWB = "Wellbeing"),
label.cex = 1.1)
plot(plot3)
#Code to plot the theoretical model (in case you don't want to print the results on the graph):
p3_theoretical <- semPlot::semPaths(Kim_2dvs_fit)
p3_theoretical <- semptools::set_sem_layout(p3_theoretical,
indicator_order = m3_indicator_order,
indicator_factor = m3_indicator_factor,
factor_layout = m3_msmt,
factor_point_to = m3_point_to,
indicator_push = m3_indicator_push,
indicator_spread = m3_indicator_spread)
plot(p3_theoretical)
#global fit indices
Kim_2dvs_fitstats <- tidySEM::table_fit(Kim_2dvs_fit)
write.csv(Kim_2dvs_fitstats, file = "Kim_2dvs_fitstats.csv")
#the code below writes the parameter estimates into a .csv file
write.csv(Kim_2dvs_pEsts, file = "Kim_2dvs_pEsts.csv")
plot_Kim_2dvs <- semPlot::semPaths(Kim_2dvs_fit, what = "col", whatLabels = "stand", sizeMan = 5, node.width = 1, edge.label.cex = .75, style = "lisrel", mar = c(5,5,5,5))
#Code to plot the theoretical model (in case you don't want to print the results on the graph):
p3_theoretical <- semPlot::semPaths(Kim_2dvs_fit)
p3_theoretical <- semptools::set_sem_layout(p3_theoretical,
indicator_order = m3_indicator_order,
indicator_factor = m3_indicator_factor,
factor_layout = m3_msmt,
factor_point_to = m3_point_to,
indicator_push = m3_indicator_push,
indicator_spread = m3_indicator_spread)
plot(p3_theoretical)
Kim_2CorrDVs_mod <- "
##measurement model
REMS =~ p1REMS + p2REMS + p3REMS
CMI =~ p1CMI + p2CMI + p3CMI
PWB =~ p1PWB + p2PWB + p3PWB
#structural model with labels for calculation of the indirect effect
CMI ~ REMS
PWB ~ REMS
"
set.seed(230916) #needed for reproducibility especially when specifying bootstrapped confidence intervals
Kim_2CorrDVs_fit <- lavaan::sem(Kim_2CorrDVs_mod, data = dfKim, missing= 'fiml', fixed.x = TRUE)
Kim_2CorrDVs_summary <- lavaan::summary(Kim_2CorrDVs_fit, fit.measures=TRUE, standardized=TRUE, rsq = TRUE)
Kim_2CorrDVs_pEsts <- lavaan::parameterEstimates(Kim_2CorrDVs_fit, boot.ci.type = "bca.simple", standardized=TRUE)
Kim_2CorrDVs_summary
#Kim_2CorrDVs_pEsts#although creating the object is useful to export as a .csv I didn't ask it to print into the book
#global fit indices
Kim_2CorrDVs_fitstats <- tidySEM::table_fit(Kim_2CorrDVs_fit)
write.csv(Kim_2CorrDVs_fitstats, file = "Kim_2CorrDVs_fitstats.csv")
#the code below writes the parameter estimates into a .csv file
write.csv(Kim_2CorrDVs_pEsts, file = "Kim_2CorrDVs_pEsts.csv")
plot_Kim_2CorrDVs <- semPlot::semPaths(Kim_2CorrDVs_fit, what = "col", whatLabels = "stand", sizeMan = 5, node.width = 1, edge.label.cex = .75, style = "lisrel", mar = c(5,5,5,5))
#IMPORTANT:  Must use the node names (take directly from the SemPlot) assigned by SemPlot
#You can change them as the last thing
m4_msmt <- semptools::layout_matrix(REM = c(2,1),
CMI = c(1,2),
PWB = c(3,2))
#tell where you want the indicators to face
m4_point_to <- semptools::layout_matrix (left = c(2,1),
right = c(1,2),
right = c(3,2))
#the next two codes -- indicator_order and indicator_factor are paired together, they specify the order of observed variables for each factor
m4_indicator_order <- c("p1R", "p2R", "p3R",
"p1C", "p2C", "p3C",
"p1P", "p2P", "p3P")
m4_indicator_factor <- c("REM", "REM", "REM",
"CMI", "CMI", "CMI",
"PWB", "PWB", "PWB")
#next set of code pushes the indicator variables away from the factor
m4_indicator_push <- c(REM = .5,
CMI = 1,
PWB = 1)
m4_indicator_spread <- c(REM = 1, #spreading the boxes away from each other
CMI = 1,
PWB = 1)
#assemble all the instructions
plot4 <- semptools::set_sem_layout(plot_Kim_2CorrDVs,
indicator_order = m4_indicator_order,
indicator_factor = m4_indicator_factor,
factor_layout = m4_msmt,
factor_point_to = m4_point_to,
indicator_push = m4_indicator_push,
indicator_spread = m4_indicator_spread)
#changing node labels
plot4 <- semptools::change_node_label(plot4,
c(REM = "mAggress",
CMI = "cMistrust",
PWB = "Wellbeing"),
label.cex = 1.1)
plot(plot4)
#Code to plot the theoretical model (in case you don't want to print the results on the graph):
p4_theoretical <- semPlot::semPaths(Kim_2CorrDVs_fit)
p4_theoretical <- semptools::set_sem_layout(p4_theoretical,
indicator_order = m4_indicator_order,
indicator_factor = m4_indicator_factor,
factor_layout = m4_msmt,
factor_point_to = m4_point_to,
indicator_push = m4_indicator_push,
indicator_spread = m4_indicator_spread)
plot(p4_theoretical)
lavaan::lavTestLRT(rp3_msmt_fit, Kim_struct_fit, Kim_swap_fit, Kim_2dvs_fit, Kim_2CorrDVs_fit)
raw <- readRDS("ReC.rds")
babydf <- dplyr::select(raw, Centering, ClearResponsibilities, EffectiveAnswers, Feedback, ClearOrganization, ClearPresentation, InclusvClassrm, EquitableEval, MultPerspectives, DEIintegration)
View(babydf)
str(babydf)
babydf$CENTERING <- as.numeric(babydf$Centering)
babydf$CENTERING <- (babydf$CENTERING - 1)
str(babydf)
msmt_mod <- "
##measurement model
CTR =~ CENTERING #this is a single item indicator, I had to add code below to set the variance
TradPed =~ ClearResponsibilities + EffectiveAnswers + Feedback + ClearOrganization + ClearPresentation
SRPed =~ InclusvClassrm + EquitableEval + MultPerspectives + DEIintegration
# Variance of the single item indicator
CENTERING ~~ 0*CENTERING
# Covariances
CTR ~~ TradPed
CTR ~~ SRPed
TradPed ~~ SRPed
"
set.seed(230916)
msmt_fit <- lavaan::cfa(msmt_mod, data = babydf, missing = "fiml")
msmt_fit_sum <- lavaan::summary(msmt_fit, fit.measures = TRUE, standardized = TRUE)
msmt_fit_sum
msmt_fit_pEsts <- lavaan::parameterEstimates(msmt_fit, boot.ci.type = "bca.simple", standardized=TRUE)
#msmt_fit_pEsts #To reduce redundancy in the book, I did not print the parameter estimates. Their object is used in exporting a .csv file.
#global fit indices
msmt_globalfit <- tidySEM::table_fit(msmt_fit)
write.csv(msmt_globalfit, file = "msmt_globalfit.csv")
#the code below writes the parameter estimates into a .csv file
write.csv(msmt_fit_pEsts, file = "msmt_fit_pEsts.csv")
semPlot::semPaths(msmt_fit, what = "col", whatLabels = "stand", sizeMan = 5, node.width = 1, edge.label.cex = .75, style = "lisrel", mar = c(5,5,5,5))
#Code to plot the theoretical model (in case you don't want to print the results on the graph):
p_msmt_diag <- semPlot::semPaths(msmt_fit)
ReC_struct_mod <- "
#measurement model
CTR =~ CENTERING #this is a single item indicator, I had to add code below to set the variance
TradPed =~ ClearResponsibilities + EffectiveAnswers + Feedback + ClearOrganization + ClearPresentation
SRPed =~ InclusvClassrm + EquitableEval + MultPerspectives + DEIintegration
# Variance of the single item indicator
CENTERING ~~ 0*CENTERING
#structural model with labels for calculation of the indirect effect
SRPed ~ b*TradPed + c_p*CTR
TradPed ~a*CTR
#calculations
indirect :=  a*b
direct  := c_p
total_c  := c_p + (a*b)
"
set.seed(230916) #needed for reproducibility especially when specifying bootstrapped confidence intervals
ReC_struct_fit <- lavaan::sem(ReC_struct_mod, data = babydf, missing= 'fiml')
ReC_struct_summary <- lavaan::summary(ReC_struct_fit, fit.measures=TRUE, standardized=TRUE, rsq = TRUE)
ReC_struct_pEsts <- lavaan::parameterEstimates(ReC_struct_fit, boot.ci.type = "bca.simple", standardized=TRUE)
ReC_struct_summary
#ReC_struct_pEsts #although creating the object is useful to export as a .csv I didn't ask it to print into the book
#global fit indices
ReC_globalfit <- tidySEM::table_fit(ReC_struct_fit)
write.csv(ReC_globalfit, file = "ReC_globalfit.csv")
#the code below writes the parameter estimates into a .csv file
write.csv(ReC_struct_pEsts, file = "ReC_struct_pEsts.csv")
plot_ReC_struct <- semPlot::semPaths(ReC_struct_fit, what = "col", whatLabels = "stand", sizeMan = 5, node.width = 1, edge.label.cex = .75, style = "lisrel", mar = c(5,5,5,5))
#IMPORTANT:  Must use the node names (take directly from the SemPlot) assigned by SemPlot
#You can change them as the last thing
m1_msmt <- semptools::layout_matrix(CTR = c(2,1),
TrP = c(1,2),
SRP = c(2,3))
#tell where you want the indicators to face
m1_point_to <- semptools::layout_matrix (left = c(2,1),
up = c(1,2),
right = c(2,3))
#the next two codes -- indicator_order and indicator_factor are paired together, they specify the order of observed variables for each factor
m1_indicator_order <- c("ClR", "EfA", "Fdb", "ClO", "ClP",
"InC", "EqE", "MlP", "DEI",
"CEN")
m1_indicator_factor <- c("TrP", "TrP", "TrP", "TrP", "TrP",
"SRP", "SRP", "SRP", "SRP",
"CTR")
#next set of code pushes the indicator variables away from the factor
m1_indicator_push <- c(CTR = 1,
TrP = 2,
SRP = 5)
m1_indicator_spread <- c(CTR = 1, #spreading the boxes away from each other
TrP = 3,
SRP = 5)
plot1 <- semptools::set_sem_layout(plot_ReC_struct,
indicator_order = m1_indicator_order,
indicator_factor = m1_indicator_factor,
factor_layout = m1_msmt,
factor_point_to = m1_point_to,
indicator_push = m1_indicator_push,
indicator_spread = m1_indicator_spread)
#changing node labels
plot1 <- semptools::change_node_label(plot1,
c(CTR = "Centering",
TrP = "TradPed",
SRP = "SRPed"),
label.cex = 1.1)
plot(plot1)
#Code to plot the theoretical model (in case you don't want to print the results on the graph):
ReC1_theo <- semPlot::semPaths(ReC_struct_fit)
ReC1_theo <-semptools::set_sem_layout(ReC1_theo,
indicator_order = m1_indicator_order,
indicator_factor = m1_indicator_factor,
factor_layout = m1_msmt,
factor_point_to = m1_point_to,
indicator_push = m1_indicator_push,
indicator_spread = m1_indicator_spread)
plot(ReC1_theo)
ReC_ALT_mod <- "
#measurement model
CTR =~ CENTERING #this is a single item indicator, I had to add code below to set the variance
TradPed =~ ClearResponsibilities + EffectiveAnswers + Feedback + ClearOrganization + ClearPresentation
SRPed =~ InclusvClassrm + EquitableEval + MultPerspectives + DEIintegration
# Variance of the single item indicator
CENTERING ~~ 0*CENTERING
TradPed~~0*SRPed
#structural model with labels for calculation of the indirect effect
SRPed ~ CTR
TradPed ~ CTR
"
set.seed(230916) #needed for reproducibility especially when specifying bootstrapped confidence intervals
ReC_ALT_fit <- lavaan::sem(ReC_ALT_mod, data = babydf, missing= 'fiml', fixed.x= FALSE)
ReC_ALT_summary <- lavaan::summary(ReC_ALT_fit, fit.measures=TRUE, standardized=TRUE, rsq = TRUE)
ReC_ALT_pEsts <- lavaan::parameterEstimates(ReC_ALT_fit, boot.ci.type = "bca.simple", standardized=TRUE)
ReC_ALT_summary
#ReC_ALT_pEsts #although creating the object is useful to export as a .csv I didn't ask it to print into the book
#global fit indices
ReC_ALT_globalfit <- tidySEM::table_fit(ReC_ALT_fit)
write.csv(ReC_ALT_globalfit, file = "ReC_ALT_globalfit.csv")
#the code below writes the parameter estimates into a .csv file
write.csv(ReC_ALT_pEsts, file = "ReC_ALT_pEsts.csv")
plot_ReC_ALT <- semPlot::semPaths(ReC_ALT_fit, what = "col", whatLabels = "stand", sizeMan = 5, node.width = 1, edge.label.cex = .75, style = "lisrel", mar = c(5,5,5,5))
#IMPORTANT:  Must use the node names (take directly from the SemPlot) assigned by SemPlot
#You can change them as the last thing
m2_msmt <- semptools::layout_matrix(CTR = c(2,1),
TrP = c(1,2),
SRP = c(3,2))
#tell where you want the indicators to face
m2_point_to <- semptools::layout_matrix (left = c(2,1),
right = c(1,2),
right = c(3,2))
#the next two codes -- indicator_order and indicator_factor are paired together, they specify the order of observed variables for each factor
m2_indicator_order <- c("ClR", "EfA", "Fdb", "ClO", "ClP",
"InC", "EqE", "MlP", "DEI",
"CEN")
m2_indicator_factor <- c("TrP", "TrP", "TrP", "TrP", "TrP",
"SRP", "SRP", "SRP", "SRP",
"CTR")
#next set of code pushes the indicator variables away from the factor
m2_indicator_push <- c(CTR = 1,
TrP = 2,
SRP = 5)
m2_indicator_spread <- c(CTR = 1, #spreading the boxes away from each other
TrP = 3,
SRP = 5)
plot2 <- semptools::set_sem_layout(plot_ReC_ALT,
indicator_order = m2_indicator_order,
indicator_factor = m2_indicator_factor,
factor_layout = m2_msmt,
factor_point_to = m2_point_to,
indicator_push = m2_indicator_push,
indicator_spread = m2_indicator_spread)
#changing node labels
plot21 <- semptools::change_node_label(plot2,
c(CTR = "Centering",
TrP = "TradPed",
SRP = "SRPed"),
label.cex = 1.1)
plot(plot2)
#Code to plot the theoretical model (in case you don't want to print the results on the graph):
ReC_ALT <- semPlot::semPaths(ReC_ALT_fit)
ReC_ALT <-semptools::set_sem_layout(ReC_ALT,
indicator_order = m2_indicator_order,
indicator_factor = m2_indicator_factor,
factor_layout = m2_msmt,
factor_point_to = m2_point_to,
indicator_push = m2_indicator_push,
indicator_spread = m2_indicator_spread)
plot(ReC_ALT)
lavaan::lavTestLRT(msmt_fit, ReC_struct_fit, ReC_ALT_fit)
