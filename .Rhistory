cov_mat <- sd %*% t(sd) * r_mat
cov_mat
#Set random seed so that the following matrix always gets the same results.
set.seed(210403)
library(MASS)
Lewis_df <- mvrnorm(n = 212, mu=mu, Sigma = cov_mat, empirical = TRUE)
colMeans(Lewis_df)
#Checking our work against the original correlation matrix
cor(Lewis_df)
as.data.frame(Lewis_df, row.names = NULL, optional = FALSE, make.names = TRUE)
library(tidyverse)
Lewis_df <- Lewis_df%>%
as.data.frame %>%
rename(GRMS = V1, Sprtlty = V2, SocSup = V3, Engmt = V4, DisEngmt = V5, GRIcntlty = V6, MtnlHlth = V7, PhysHlth = V8)
head(Lewis_df)
library(psych)
psych::describe(Lewis_df)
psych::pairs.panels(Lewis_df)
set.seed(210403)
library(lavaan)
parallel_Lewis <- '
MtnlHlth ~ b1*Engmt + b2*DisEngmt + c_p*GRMS
Engmt ~ a1*GRMS
DisEngmt ~ a2*GRMS
indirect1 := a1 * b1
indirect2 := a2 * b2
contrast := indirect1 - indirect2
total_indirects := indirect1 + indirect2
total_c := c_p + (indirect1) + (indirect2)
direct := c_p
'
para_Lewis_fit <- sem(parallel_Lewis, data = Lewis_df, se = "bootstrap", bootstrap = 1000, missing = 'fiml') #holds the "whole" result
pLewis_sum <- summary(para_Lewis_fit , standardized = TRUE, rsq=T, fit=TRUE, ci=TRUE) #today, we really only need the R-squared from here
pLewis_ParEsts <- parameterEstimates(para_Lewis_fit, boot.ci.type = "bca.simple", standardized=TRUE) #provides our estimates, se, p values for all the elements we specified
#Entering the intercorrelations, means, and standard deviations from the journal article
mu <- c(.34, 3.00, 2.98, 2.36, 3.50, 1.64)
sd <- c(.16, .83, .99, .90, .90, .53)
r_mat <- matrix (c(1,   .59, .26,   .34,  -.25, -.02,
.59, 1.00, .12,   .19,  -.28, .00,
.26,  .12, 1.00, .66,  -.55, .07,
.34,  .19, .66,  1.00, -.66, .05,
-.25, -.28, -.55,-.66,  1.00, .08,
-.02,  .00,  .07, .05, .08,  1), ncol = 6)
#Creating a covariance matrix
cov_mat <- sd %*% t(sd) * r_mat
#Set random seed so that the following matrix always gets the same results.
set.seed(210409)
library(MASS)
Kim_df <- mvrnorm(n = 156, mu=mu, Sigma = cov_mat, empirical = TRUE)
colMeans(Kim_df)
#Checking our work against the original correlation matrix
round(cor(Kim_df),3)
#renaming the variables
as.data.frame(Kim_df, row.names = NULL, optional = FALSE, make.names = TRUE)
library(tidyverse)
Kim_df <- Kim_df%>%
as.data.frame %>%
rename(REMS = V1, CMI = V2, ANX = V3, DEP = V4, PWB = V5, HlpSk = V6)
#only have to run this ONCE to draw from the same Qualtrics account...but will need to get different token if you are changing between accounts
library(qualtRics)
qualtrics_api_credentials(api_key = "mUgPMySYkiWpMFkwHale1QE5HNmh5LRUaA8d9PDg",
base_url = "spupsych.az1.qualtrics.com", overwrite = TRUE, install = TRUE)
#readRenviron("~/.Renviron")
#only have to run this ONCE to draw from the same Qualtrics account...but will need to get different token if you are changing between accounts
library(qualtRics)
qualtrics_api_credentials(api_key = "mUgPMySYkiWpMFkwHale1QE5HNmh5LRUaA8d9PDg",
base_url = "spupsych.az1.qualtrics.com", overwrite = TRUE, install = TRUE)
readRenviron("~/.Renviron")
readRenviron("~/.Renviron")
#only have to run this ONCE to draw from the same Qualtrics account...but will need to get different token if you are changing between accounts
library(qualtRics)
qualtrics_api_credentials(api_key = "mUgPMySYkiWpMFkwHale1QE5HNmh5LRUaA8d9PDg",
base_url = "spupsych.az1.qualtrics.com", overwrite = TRUE, install = TRUE)
readRenviron("~/.Renviron")
readRenviron("~/.Renviron")
item_scores_df <- read.csv ("BlStItmsScrs210320.csv", head = TRUE, sep = ",")
library(psych)
library(formattable)
Bel_alpha <- psych::alpha(item_scores_df[c("Belong_1", "Belong_2", "Belong_3")])
Bel_alpha
CClim_alpha <- psych::alpha(item_scores_df[c("rBlst_1", "Blst_2", "Blst_3", "Blst_4", "Blst_5", "Blst_6")])
CClim_alpha
Stigma_alpha <- psych::alpha(item_scores_df[c("Blst_3", "Blst_2", "Blst_5")])
Stigma_alpha
Resp_alpha <- psych::alpha(item_scores_df[c("rBlst_1", "Blst_4", "Blst_6")])
Resp_alpha
str(item_scores_df)
# the script may look a little complicated; I could have simply written
# describe(item_scores_df) #it would have given me descriptives for all the items in the df
# because I only wanted a few variables, I provided them in a concatenated: list [c("iBIPOC_pr", "cmBlack", "Belonging", "ClimateBL")]
# I also added "psych::" in front of the command to make sure that R is using the describe function from the psych package
# I popped the output into an object; objects are not required, but can be helpful to write as outfiles, to pipe elements of inline text, and to use with packages like apaTables
# When we use an object, we need to write it below so the results will display
descriptives <- (psych::describe(item_scores_df[c("iBIPOC_pr", "cmBlack", "Belonging", "ClimateBL")]))
descriptives
write.csv (descriptives, file="DataDx_descripts.csv") #this can be useful if you wish to manually format the data for an APA style table
#The shapiro-test is in base R; it's specification is simple:  shapiro.test(df$variable)
#I added the object (and had to list it below) so I can use the inline text function
SWt_i <- shapiro.test(item_scores_df$iBIPOC_pr)
SWt_cm <- shapiro.test(item_scores_df$cmBlack)
SWt_Bel <-shapiro.test(item_scores_df$Belonging)
SWt_Cl <-shapiro.test(item_scores_df$ClimateBL)
SWt_i
SWt_cm
SWt_Bel
SWt_Cl
iSW <- digits(SWt_i$statistic, 3)
iSWp <- digits(SWt_i$p.value, 4)
iSW
iSWp
cmSW <- digits(SWt_cm$statistic, 3)
cmSWp <- digits(SWt_cm$p.value, 4)
cmSW
cmSWp
belSW <- digits(SWt_Bel$statistic, 3)
belSWp <- digits(SWt_Bel$p.value, 4)
belSW
belSWp
clSW <- digits(SWt_Cl$statistic, 3)
clSWp <- digits(SWt_Cl$p.value, 4)
clSW
clSWp
psych::pairs.panels(item_scores_df[c("iBIPOC_pr", "cmBlack", "Belonging", "ClimateBL")], stars = TRUE, lm = TRUE)
item_scores_df$Mahal <- psych::outlier(item_scores_df[c("iBIPOC_pr", "cmBlack", "Belonging", "ClimateBL")])
psych::describe(item_scores_df$Mahal)
library(dplyr)
#str(item_scores_df$Mahal)
item_scores_df$MOutlier <- if_else(item_scores_df$Mahal > (median(item_scores_df$Mahal) + (3*sd(item_scores_df$Mahal))), TRUE, FALSE)
library(dplyr)
OutlierCount <- item_scores_df%>%
count(MOutlier)
OutlierCount
NumOutliers <- nrow(item_scores_df) - OutlierCount #calculating how many outliers
NumOutliers #this object is used for the inline text for the reesults
NumOutliers
head(item_scores_df) #shows us the first 6 rows of the data so we can see the new variables (Mahal, MOutlier)
# I created an object that lists how many rows/cases remain.
# I used inline text below to update the text with the new number
attempts <- nrow(QTRX_df)
scrub_df <- read.csv ("BlackStntsModel210318.csv", head = TRUE, sep = ",")
str(scrub_df)
str(scrub_df$iRace1)
scrub_df$tRace1 = factor(scrub_df$iRace1,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
scrub_df$tRace2 = factor(scrub_df$iRace2,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
scrub_df$tRace3 = factor(scrub_df$iRace3,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
scrub_df$tRace4 = factor(scrub_df$iRace4,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
scrub_df$tRace5 = factor(scrub_df$iRace5,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
scrub_df$tRace6 = factor(scrub_df$iRace6,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
scrub_df$tRace7 = factor(scrub_df$iRace7,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
scrub_df$tRace8 = factor(scrub_df$iRace8,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
scrub_df$tRace9 = factor(scrub_df$iRace9,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
scrub_df$tRace10 = factor(scrub_df$iRace10,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
library(tidyverse)
glimpse(scrub_df)
scrub_df$count.BIPOC <- apply(scrub_df[c("tRace1", "tRace2", "tRace3", "tRace4", "tRace5", "tRace6", "tRace7", "tRace8", "tRace9", "tRace10")], 1, function(x) sum(x %in% c("Black", "nBpoc", "BiMulti")))
scrub_df$count.nMiss <- apply(scrub_df[c("tRace1", "tRace2", "tRace3", "tRace4", "tRace5", "tRace6", "tRace7", "tRace8", "tRace9", "tRace10")], 1, function(x) sum(!is.na(x)))
scrub_df$iBIPOC_pr = scrub_df$count.BIPOC/scrub_df$count.nMiss
scrub_df <-(select (scrub_df, ID, iBIPOC_pr, cmBlack, Belong_1:Belong_3, Blst_1:Blst_6))
#Calculating number and proportion of item-level missingness
scrub_df$nmiss <- scrub_df%>%
select(iBIPOC_pr:Blst_6) %>% #the colon allows us to include all variables between the two listed (the variables need to be in order)
is.na %>%
rowSums
scrub_df<- scrub_df%>%
mutate(prop_miss = (nmiss/11)*100) #11 is the number of variables included in calculating the proportion
library(formattable)
CaseMiss<-psych::describe(scrub_df$prop_miss)
CaseMiss
missMin <- digits(CaseMiss$min, 0)
missMax <- digits(CaseMiss$max, 0)
scrub_df <- filter(scrub_df, prop_miss <= 90)  #update df to have only those with at least 90% of complete data
scrub_df <- scrub_df %>%
select (-c(ID, nmiss, prop_miss))#further update to exclude the n_miss and prop_miss variables
#install.packages("formattable")
CellsMiss <- percent(mean(is.na(scrub_df)))#what proportion of cells missing across entire dataset
CaseComplete <- percent(mean(complete.cases(scrub_df)))#what proportion of cases (rows) are complete (nonmissing)
CellsMiss
CaseComplete
scrub_df<- scrub_df %>%
mutate(rBlst_1 = 8 - Blst_1) #if you had multiple items, you could add a pipe (%>%) at the end of the line and add more until the last one
library(sjstats)
#Making the list of variables
Belonging_vars <- c('Belong_1','Belong_2','Belong_3')
ResponseBL_vars <- c('rBlst_1', 'Blst_4','Blst_6')
StigmaBL_vars <- c('Blst_2', 'Blst_3','Blst_5')
ClimateBL_vars <- c('rBlst_1', 'Blst_4','Blst_6','Blst_2', 'Blst_3','Blst_5' )
#Creating the new variables
scrub_df$Belonging <- mean_n(scrub_df[,Belonging_vars], .65)
scrub_df$ResponseBL <- mean_n(scrub_df[,ResponseBL_vars], .80)
scrub_df$StigmaBL <- mean_n(scrub_df[,StigmaBL_vars], .80)
scrub_df$ClimateBL <- mean_n(scrub_df[,ClimateBL_vars], .80)
library(tidyverse)
scrub_df <- scrub_df %>% mutate(ID = row_number())
#moving the ID number to the first column; requires
scrub_df <- scrub_df%>%select(ID, everything())
write.table(scrub_df, file="BlStItmsScrs210320.csv", sep=",", col.names=TRUE, row.names=FALSE)
scored <-(select (scrub_df, iBIPOC_pr, cmBlack, Belonging, ResponseBL, StigmaBL, ClimateBL))
ScoredCaseMiss <- nrow(scored) #I produced this object for the sole purpose of feeding the number of cases into the inline text, below
scrub_df <- read.csv ("BlackStntsModel210318.csv", head = TRUE, sep = ",")
str(scrub_df)
str(scrub_df$iRace1)
scrub_df$tRace1 = factor(scrub_df$iRace1,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
scrub_df$tRace2 = factor(scrub_df$iRace2,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
scrub_df$tRace3 = factor(scrub_df$iRace3,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
scrub_df$tRace4 = factor(scrub_df$iRace4,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
scrub_df$tRace5 = factor(scrub_df$iRace5,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
scrub_df$tRace6 = factor(scrub_df$iRace6,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
scrub_df$tRace7 = factor(scrub_df$iRace7,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
scrub_df$tRace8 = factor(scrub_df$iRace8,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
scrub_df$tRace9 = factor(scrub_df$iRace9,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
scrub_df$tRace10 = factor(scrub_df$iRace10,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
library(tidyverse)
glimpse(scrub_df)
scrub_df$count.BIPOC <- apply(scrub_df[c("tRace1", "tRace2", "tRace3", "tRace4", "tRace5", "tRace6", "tRace7", "tRace8", "tRace9", "tRace10")], 1, function(x) sum(x %in% c("Black", "nBpoc", "BiMulti")))
scrub_df$count.nMiss <- apply(scrub_df[c("tRace1", "tRace2", "tRace3", "tRace4", "tRace5", "tRace6", "tRace7", "tRace8", "tRace9", "tRace10")], 1, function(x) sum(!is.na(x)))
scrub_df$iBIPOC_pr = scrub_df$count.BIPOC/scrub_df$count.nMiss
scrub_df <-(select (scrub_df, ID, iBIPOC_pr, cmBlack, Belong_1:Belong_3, Blst_1:Blst_6))
#Calculating number and proportion of item-level missingness
scrub_df$nmiss <- scrub_df%>%
select(iBIPOC_pr:Blst_6) %>% #the colon allows us to include all variables between the two listed (the variables need to be in order)
is.na %>%
rowSums
scrub_df<- scrub_df%>%
mutate(prop_miss = (nmiss/11)*100) #11 is the number of variables included in calculating the proportion
saveRDS(scrub_df, 'scrubDF.rds')
item_scores_df <- read.csv ("BlStItmsScrs210320.csv", head = TRUE, sep = ",")
library(psych)
library(formattable)
Bel_alpha <- psych::alpha(item_scores_df[c("Belong_1", "Belong_2", "Belong_3")])
Bel_alpha
CClim_alpha <- psych::alpha(item_scores_df[c("rBlst_1", "Blst_2", "Blst_3", "Blst_4", "Blst_5", "Blst_6")])
CClim_alpha
Stigma_alpha <- psych::alpha(item_scores_df[c("Blst_3", "Blst_2", "Blst_5")])
Stigma_alpha
Resp_alpha <- psych::alpha(item_scores_df[c("rBlst_1", "Blst_4", "Blst_6")])
Resp_alpha
str(item_scores_df)
# the script may look a little complicated; I could have simply written
# describe(item_scores_df) #it would have given me descriptives for all the items in the df
# because I only wanted a few variables, I provided them in a concatenated: list [c("iBIPOC_pr", "cmBlack", "Belonging", "ClimateBL")]
# I also added "psych::" in front of the command to make sure that R is using the describe function from the psych package
# I popped the output into an object; objects are not required, but can be helpful to write as outfiles, to pipe elements of inline text, and to use with packages like apaTables
# When we use an object, we need to write it below so the results will display
descriptives <- (psych::describe(item_scores_df[c("iBIPOC_pr", "cmBlack", "Belonging", "ClimateBL")]))
descriptives
write.csv (descriptives, file="DataDx_descripts.csv") #this can be useful if you wish to manually format the data for an APA style table
#The shapiro-test is in base R; it's specification is simple:  shapiro.test(df$variable)
#I added the object (and had to list it below) so I can use the inline text function
SWt_i <- shapiro.test(item_scores_df$iBIPOC_pr)
SWt_cm <- shapiro.test(item_scores_df$cmBlack)
SWt_Bel <-shapiro.test(item_scores_df$Belonging)
SWt_Cl <-shapiro.test(item_scores_df$ClimateBL)
SWt_i
SWt_cm
SWt_Bel
SWt_Cl
iSW <- digits(SWt_i$statistic, 3)
iSWp <- digits(SWt_i$p.value, 4)
iSW
iSWp
cmSW <- digits(SWt_cm$statistic, 3)
cmSWp <- digits(SWt_cm$p.value, 4)
cmSW
cmSWp
belSW <- digits(SWt_Bel$statistic, 3)
belSWp <- digits(SWt_Bel$p.value, 4)
belSW
belSWp
clSW <- digits(SWt_Cl$statistic, 3)
clSWp <- digits(SWt_Cl$p.value, 4)
clSW
clSWp
psych::pairs.panels(item_scores_df[c("iBIPOC_pr", "cmBlack", "Belonging", "ClimateBL")], stars = TRUE, lm = TRUE)
item_scores_df$Mahal <- psych::outlier(item_scores_df[c("iBIPOC_pr", "cmBlack", "Belonging", "ClimateBL")])
psych::describe(item_scores_df$Mahal)
library(dplyr)
#str(item_scores_df$Mahal)
item_scores_df$MOutlier <- if_else(item_scores_df$Mahal > (median(item_scores_df$Mahal) + (3*sd(item_scores_df$Mahal))), TRUE, FALSE)
library(dplyr)
OutlierCount <- item_scores_df%>%
count(MOutlier)
OutlierCount
NumOutliers <- nrow(item_scores_df) - OutlierCount #calculating how many outliers
NumOutliers #this object is used for the inline text for the reesults
NumOutliers
head(item_scores_df) #shows us the first 6 rows of the data so we can see the new variables (Mahal, MOutlier)
QTRX_df <-qualtRics::fetch_survey(surveyID = "SV_b2cClqAlLGQ6nLU", time_zone = NULL, verbose = FALSE, label=FALSE, convert=FALSE, force_request = TRUE, import_id = FALSE)
QTRX_df <- filter (QTRX_df, DistributionChannel != "preview")
attempts <- nrow(QTRX_df)
consented_attempts <- nrow(QTRX_df)
QTRX_df <-(filter (QTRX_df, USinst == 0))
US_inclusion <- nrow(QTRX_df)
readRDS('scrubDF')
QTRX_df <-qualtRics::fetch_survey(surveyID = "SV_b2cClqAlLGQ6nLU", time_zone = NULL, verbose = FALSE, label=FALSE, convert=FALSE, force_request = TRUE, import_id = FALSE)
QTRX_df <- filter (QTRX_df, DistributionChannel != "preview")
attempts <- nrow(QTRX_df)
consented_attempts <- nrow(QTRX_df)
QTRX_df <-(filter (QTRX_df, USinst == 0))
US_inclusion <- nrow(QTRX_df)
readRDS('scrubDF.rds')
library(formattable)
CaseMiss<-psych::describe(scrubDF$prop_miss)
QTRX_df <-qualtRics::fetch_survey(surveyID = "SV_b2cClqAlLGQ6nLU", time_zone = NULL, verbose = FALSE, label=FALSE, convert=FALSE, force_request = TRUE, import_id = FALSE)
QTRX_df <- filter (QTRX_df, DistributionChannel != "preview")
attempts <- nrow(QTRX_df)
consented_attempts <- nrow(QTRX_df)
QTRX_df <-(filter (QTRX_df, USinst == 0))
US_inclusion <- nrow(QTRX_df)
scrubDF <- readRDS('scrubDF.rds')
library(formattable)
CaseMiss<-psych::describe(scrubDF$prop_miss)
CaseMiss
missMin <- digits(CaseMiss$min, 0)
missMax <- digits(CaseMiss$max, 0)
scrubDF <- filter(scrubDF, prop_miss <= 90)  #update df to have only those with at least 90% of complete data
scrubDF <- scrubDF %>%
select (-c(ID, nmiss, prop_miss))#further update to exclude the n_miss and prop_miss variables
CellsMiss <- percent(mean(is.na(scrubDF)))#what proportion of cells missing across entire dataset
CaseComplete <- percent(mean(complete.cases(scrubDF)))#what proportion of cases (rows) are complete (nonmissing)
saveRDS(scored, 'SCORED.rds')
scrub_df <- read.csv ("BlackStntsModel210318.csv", head = TRUE, sep = ",")
str(scrub_df)
str(scrub_df$iRace1)
scrub_df$tRace1 = factor(scrub_df$iRace1,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
scrub_df$tRace2 = factor(scrub_df$iRace2,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
scrub_df$tRace3 = factor(scrub_df$iRace3,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
scrub_df$tRace4 = factor(scrub_df$iRace4,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
scrub_df$tRace5 = factor(scrub_df$iRace5,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
scrub_df$tRace6 = factor(scrub_df$iRace6,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
scrub_df$tRace7 = factor(scrub_df$iRace7,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
scrub_df$tRace8 = factor(scrub_df$iRace8,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
scrub_df$tRace9 = factor(scrub_df$iRace9,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
scrub_df$tRace10 = factor(scrub_df$iRace10,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
library(tidyverse)
glimpse(scrub_df)
scrub_df$count.BIPOC <- apply(scrub_df[c("tRace1", "tRace2", "tRace3", "tRace4", "tRace5", "tRace6", "tRace7", "tRace8", "tRace9", "tRace10")], 1, function(x) sum(x %in% c("Black", "nBpoc", "BiMulti")))
scrub_df$count.nMiss <- apply(scrub_df[c("tRace1", "tRace2", "tRace3", "tRace4", "tRace5", "tRace6", "tRace7", "tRace8", "tRace9", "tRace10")], 1, function(x) sum(!is.na(x)))
scrub_df$iBIPOC_pr = scrub_df$count.BIPOC/scrub_df$count.nMiss
scrub_df <-(select (scrub_df, ID, iBIPOC_pr, cmBlack, Belong_1:Belong_3, Blst_1:Blst_6))
#Calculating number and proportion of item-level missingness
scrub_df$nmiss <- scrub_df%>%
select(iBIPOC_pr:Blst_6) %>% #the colon allows us to include all variables between the two listed (the variables need to be in order)
is.na %>%
rowSums
scrub_df<- scrub_df%>%
mutate(prop_miss = (nmiss/11)*100) #11 is the number of variables included in calculating the proportion
saveRDS(scrub_df, 'scrubDF.rds')
library(formattable)
CaseMiss<-psych::describe(scrub_df$prop_miss)
CaseMiss
missMin <- digits(CaseMiss$min, 0)
missMax <- digits(CaseMiss$max, 0)
scrub_df <- filter(scrub_df, prop_miss <= 90)  #update df to have only those with at least 90% of complete data
scrub_df <- scrub_df %>%
select (-c(ID, nmiss, prop_miss))#further update to exclude the n_miss and prop_miss variables
#install.packages("formattable")
CellsMiss <- percent(mean(is.na(scrub_df)))#what proportion of cells missing across entire dataset
CaseComplete <- percent(mean(complete.cases(scrub_df)))#what proportion of cases (rows) are complete (nonmissing)
CellsMiss
CaseComplete
scrub_df<- scrub_df %>%
mutate(rBlst_1 = 8 - Blst_1) #if you had multiple items, you could add a pipe (%>%) at the end of the line and add more until the last one
library(sjstats)
#Making the list of variables
Belonging_vars <- c('Belong_1','Belong_2','Belong_3')
ResponseBL_vars <- c('rBlst_1', 'Blst_4','Blst_6')
StigmaBL_vars <- c('Blst_2', 'Blst_3','Blst_5')
ClimateBL_vars <- c('rBlst_1', 'Blst_4','Blst_6','Blst_2', 'Blst_3','Blst_5' )
#Creating the new variables
scrub_df$Belonging <- mean_n(scrub_df[,Belonging_vars], .65)
scrub_df$ResponseBL <- mean_n(scrub_df[,ResponseBL_vars], .80)
scrub_df$StigmaBL <- mean_n(scrub_df[,StigmaBL_vars], .80)
scrub_df$ClimateBL <- mean_n(scrub_df[,ClimateBL_vars], .80)
library(tidyverse)
scrub_df <- scrub_df %>% mutate(ID = row_number())
#moving the ID number to the first column; requires
scrub_df <- scrub_df%>%select(ID, everything())
write.table(scrub_df, file="BlStItmsScrs210320.csv", sep=",", col.names=TRUE, row.names=FALSE)
scored <-(select (scrub_df, iBIPOC_pr, cmBlack, Belonging, ResponseBL, StigmaBL, ClimateBL))
ScoredCaseMiss <- nrow(scored) #I produced this object for the sole purpose of feeding the number of cases into the inline text, below
saveRDS(scored, 'SCORED.rds')
SCORED <- readRDS('SCORED.rds')
ScoredCaseMiss <- nrow(SCORED)
#Create a variable (n_miss) that counts the number missing
SCORED$n_miss <- SCORED%>%
select(iBIPOC_pr:ClimateBL) %>%
is.na %>%
rowSums
SCORED<- SCORED%>%
mutate(prop_miss = (n_miss/6)*100)%>%
arrange(desc(n_miss))
ScoredPrMiss <- psych::describe(SCORED$prop_miss)
ScrdMissMin <- digits(ScoredPrMiss$min, 0)#this object is displayed below and I use input from  it for the inline text used in the write-up
ScrdMissMax <- digits(ScoredPrMiss$max, 0)
SCORED <- filter(SCORED, prop_miss <= 20)  #update df to have only those with at least 20% of complete data (this is an arbitrary decision)
SCORED <-(select (SCORED, iBIPOC_pr:ClimateBL)) #the variable selection just lops off the proportion missing
ScoredCasesIncluded <- nrow(SCORED)
PrScoredCellsMissing <-percent(mean(is.na(SCORED))) #percent missing across df
PrScoredRowsMissing <- percent(mean(complete.cases(SCORED))) #percent of rows with nonmissing data
#obtained with the survey ID
#"surveyID" should be the ID from above
#"verbose" prints messages to the R console
#"label", when TRUE, imports data as text responses; if FALSE prints the data as numerical responses
#"convert", when TRUE, attempts to convert certain question types to the "proper" data type in R; because I don't like guessing, I want to set up my own factors.
#"force_request", when TRUE, always downloads the survey from the API instead of from a temporary directory (i.e., it always goes to the primary source)
# "import_id", when TRUE includes the unique Qualtrics-assigned ID; since I have provided labels, I want false
QTRX_df <-qualtRics::fetch_survey(surveyID = "SV_b2cClqAlLGQ6nLU", time_zone = NULL, verbose = FALSE, label=FALSE, convert=FALSE, force_request = TRUE, import_id = FALSE)
#useLocalTime = TRUE,
#obtained with the survey ID
#"surveyID" should be the ID from above
#"verbose" prints messages to the R console
#"label", when TRUE, imports data as text responses; if FALSE prints the data as numerical responses
#"convert", when TRUE, attempts to convert certain question types to the "proper" data type in R; because I don't like guessing, I want to set up my own factors.
#"force_request", when TRUE, always downloads the survey from the API instead of from a temporary directory (i.e., it always goes to the primary source)
# "import_id", when TRUE includes the unique Qualtrics-assigned ID; since I have provided labels, I want false
QTRX_df230901 <-qualtRics::fetch_survey(surveyID = "SV_b2cClqAlLGQ6nLU", time_zone = NULL, verbose = FALSE, label=FALSE, convert=FALSE, force_request = TRUE, import_id = FALSE)
#useLocalTime = TRUE,
#write the simulated data as a .csv
write.table(QTRX_df230901, file="QTRX_df230901.csv", sep=",", col.names=TRUE, row.names=FALSE)
#bring back the simulated dat from a .csv file
QTRX_df <- read.csv("QTRX_df23090.csv", header = TRUE)
#write the simulated data as a .csv
write.table(QTRX_df230901, file="QTRX_df230901.csv", sep=",", col.names=TRUE, row.names=FALSE)
#bring back the simulated dat from a .csv file
QTRX_df <- read.csv("QTRX_df230901.csv", header = TRUE)
#to save the df as an .rds (think "R object") file on your computer; it should save in the same file as the .rmd file you are working with
saveRDS(QTRX_df230901, "QTRX_df230901")
#bring back the simulated dat from an .rds file
QTRX_df <- readRDS("QTRX_df230901.rds")
saveRDS(QTRX_df230901, "QTRX_df230901.rds")
#bring back the simulated dat from an .rds file
QTRX_df <- readRDS("QTRX_df230901.rds")
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(comment = NA) #keeps out the hashtags in the knits
options(scipen=999)#eliminates scientific notation
#obtained with the survey ID
#"surveyID" should be the ID from above
#"verbose" prints messages to the R console
#"label", when TRUE, imports data as text responses; if FALSE prints the data as numerical responses
#"convert", when TRUE, attempts to convert certain question types to the "proper" data type in R; because I don't like guessing, I want to set up my own factors.
#"force_request", when TRUE, always downloads the survey from the API instead of from a temporary directory (i.e., it always goes to the primary source)
# "import_id", when TRUE includes the unique Qualtrics-assigned ID; since I have provided labels, I want false
QTRX_df230901 <-qualtRics::fetch_survey(surveyID = "SV_b2cClqAlLGQ6nLU", time_zone = NULL, verbose = FALSE, label=FALSE, convert=FALSE, force_request = TRUE, import_id = FALSE)
#useLocalTime = TRUE,
#write the simulated data as a .csv
#write.table(QTRX_df230901, file="QTRX_df230901.csv", sep=",", col.names=TRUE, row.names=FALSE)
#bring back the simulated dat from a .csv file
#QTRX_df <- read.csv("QTRX_df230901.csv", header = TRUE)
#to save the df as an .rds (think "R object") file on your computer; it should save in the same file as the .rmd file you are working with
saveRDS(QTRX_df230901, "QTRX_df230901.rds")
#bring back the simulated dat from an .rds file
QTRX_df <- readRDS("QTRX_df230901.rds")
