set.seed(230925)
dfLewis <- lavaan::simulateData(model = Lewis_generating_model,
model.type = "sem",
meanstructure = T,
sample.nobs=231,
standardized=FALSE)
#used to retrieve column indices used in the rescaling script below
#col_index <- as.data.frame(colnames(dfLewis))
for(i in 1:ncol(dfLewis)){  # for loop to go through each column of the dataframe
if(i >= 1 & i <= 25){   # apply only to GRMS variables
dfLewis[,i] <- scales::rescale(dfLewis[,i], c(0, 5))
}
if(i >= 26 & i <= 37){   # apply only to mental and physical health variables
dfLewis[,i] <- scales::rescale(dfLewis[,i], c(0, 6))
}
if(i >= 38 & i <= 45){   # apply only to coping variables
dfLewis[,i] <- scales::rescale(dfLewis[,i], c(1, 4))
}
if(i >= 46 & i <= 55){   # apply only to GRIC variables
dfLewis[,i] <- scales::rescale(dfLewis[,i], c(1, 7))
}
}
#rounding to integers so that the data resembles that which was collected
library(tidyverse)
dfLewis <- dfLewis %>% round(0)
#quick check of my work
#psych::describe(dfLewis)
#saveRDS(dfLewis, 'dfLewis.rds')
#dfLewis<- readRDS('dfLewis.rds')
#write.table(dfLewis, file = 'dfLewis.csv', sep = ',', col.names=TRUE, row.names=FALSE)
#dfLewis<- read.csv ('dfLewis.csv', header = TRUE)
GRMS_vars <- c("Ob1", "Ob2", "Ob3", "Ob4", "Ob5", "Ob6", "Ob7", "Ob8", "Ob9", "Ob10", "Ma1", "Ma2", "Ma3", "Ma4", "Ma5", "Ma6", "Ma7", "St1", "St2", "St3", "St4", "St5", "An1", "An2", "An3")
Eng_vars <- c("Eng1", "Eng2")
dEng_vars <- c("dEng1", "dEng2")
MntlHlth_vars <- c("MH1", "MH2", "MH3", "MH4", "MH5", "MH6")
Cntrlty_vars <- c("Cntrlty1", "Cntrlty2", "Cntrlty3", "Cntrlty4", "Cntrlty5", "Cntrlty6", "Cntrlty7", "Cntrlty8", "Cntrlty9", "Cntrlty10")
dfLewis$GRMS <- sjstats::mean_n(dfLewis[, GRMS_vars], 0.80)
dfLewis$Engmt <- sjstats::mean_n(dfLewis[, Eng_vars], 0.80)
dfLewis$DisEngmt <- sjstats::mean_n(dfLewis[, dEng_vars], 0.80)
dfLewis$MntlHlth <- sjstats::mean_n(dfLewis[, MntlHlth_vars], 0.80)
dfLewis$Centrality <- sjstats::mean_n(dfLewis[, Cntrlty_vars], 0.80)
#If the scoring code above does not work for you, try the format below which involves inserting to periods in front of the variable list. One example is provided.
#dfLewis$GRMS <- sjstats::mean_n(dfLewis[, ..GRMS_vars], 0.80)
Lewis_df <- dplyr::select(dfLewis, GRMS, Centrality, DisEngmt, MntlHlth)
Lewis_table <- apaTables::apa.cor.table(Lewis_df, table.number = 1, show.sig.stars=TRUE, landscape=TRUE, filename="Lewis_Corr.doc")
print(Lewis_table)
library(psych)
psych::describe(Lewis_df)
options(scipen=999)#eliminates scientific notation
#will install the package if not already installed
if(!require(lavaan)){install.packages("lavaan")}
if(!require(semPlot)){install.packages("semPlot")}
if(!require(tidyverse)){install.packages("tidyverse")}
if(!require(psych)){install.packages("psych")}
if(!require(jtools)){install.packages("jtools")}
#Entering the intercorrelations, means, and standard deviations from the journal article
Lewis_generating_model <- '
##measurement model
GRMS  =~ .69*Ob1 + .69*Ob2 + .60*Ob3 + .59*Ob4 + .55*Ob5 + .55*Ob6 + .54*Ob7 + .50*Ob8 + .41*Ob9 + .41*Ob10 + .93*Ma1 + .81*Ma2 + .69*Ma3 + .67*Ma4 + .61*Ma5 + .58*Ma6 + .54*Ma7 + .59*St1 + .55*St2 + .54*St3 + .54*St4 + .51*St5 + .70*An1 + .69*An2 + .68*An3
MntlHlth  =~ .8*MH1 + .8*MH2 + .8*MH3 + .8*MH4 + .8*MH5 + .8*MH6
PhysHlth  =~ .8*PhH1 + .8*PhH2 + .8*PhH3 + .8*PhH4 + .8*PhH5 + .8*PhH6
Spirituality  =~ .8*Spirit1 + .8*Spirit2
SocSupport  =~ .8*SocS1 + .8*SocS2
Engagement  =~ .8*Eng1 + .8*Eng2
Disengagement  =~  .8*dEng1 + .8*dEng2
GRIC  =~ .8*Cntrlty1 + .8*Cntrlty2 + .8*Cntrlty3 + .8*Cntrlty4 + .8*Cntrlty5 + .8*Cntrlty6 + .8*Cntrlty7 + .8*Cntrlty8 + .8*Cntrlty9 + .8*Cntrlty10
# Means
GRMS ~ 1.99*1
Spirituality ~2.82*1
SocSupport ~ 2.48*1
Engagement ~ 2.32*1
Disengagement ~ 1.75*1
GRIC ~ 5.71*1
MntlHlth ~3.56*1 #Lewis et al used sums instead of means, I recast as means to facilitate simulation
PhysHlth ~ 3.51*1 #Lewis et al used sums instead of means, I recast as means to facilitate simulation
# Correlations
GRMS ~ 0.20*Spirituality
GRMS ~ 0.28*SocSupport
GRMS ~ 0.30*Engagement
GRMS ~ 0.41*Disengagement
GRMS ~ 0.19*GRIC
GRMS ~ -0.32*MntlHlth
GRMS ~ -0.18*PhysHlth
Spirituality ~ 0.49*SocSupport
Spirituality ~ 0.57*Engagement
Spirituality ~ 0.22*Disengagement
Spirituality ~ 0.12*GRIC
Spirituality ~ -0.06*MntlHlth
Spirituality ~ -0.13*PhysHlth
SocSupport ~ 0.46*Engagement
SocSupport ~ 0.26*Disengagement
SocSupport ~ 0.38*GRIC
SocSupport ~ -0.18*MntlHlth
SocSupport ~ -0.08*PhysHlth
Engagement ~ 0.37*Disengagement
Engagement ~ 0.08*GRIC
Engagement ~ -0.14*MntlHlth
Engagement ~ -0.06*PhysHlth
Disengagement ~ 0.05*GRIC
Disengagement ~ -0.54*MntlHlth
Disengagement ~ -0.28*PhysHlth
GRIC ~ -0.10*MntlHlth
GRIC ~ 0.14*PhysHlth
MntlHlth ~ 0.47*PhysHlth
'
set.seed(230925)
dfLewis <- lavaan::simulateData(model = Lewis_generating_model,
model.type = "sem",
meanstructure = T,
sample.nobs=231,
standardized=FALSE)
#used to retrieve column indices used in the rescaling script below
#col_index <- as.data.frame(colnames(dfLewis))
for(i in 1:ncol(dfLewis)){  # for loop to go through each column of the dataframe
if(i >= 1 & i <= 25){   # apply only to GRMS variables
dfLewis[,i] <- scales::rescale(dfLewis[,i], c(0, 5))
}
if(i >= 26 & i <= 37){   # apply only to mental and physical health variables
dfLewis[,i] <- scales::rescale(dfLewis[,i], c(0, 6))
}
if(i >= 38 & i <= 45){   # apply only to coping variables
dfLewis[,i] <- scales::rescale(dfLewis[,i], c(1, 4))
}
if(i >= 46 & i <= 55){   # apply only to GRIC variables
dfLewis[,i] <- scales::rescale(dfLewis[,i], c(1, 7))
}
}
#rounding to integers so that the data resembles that which was collected
library(tidyverse)
dfLewis <- dfLewis %>% round(0)
#quick check of my work
#psych::describe(dfLewis)
#saveRDS(dfLewis, 'dfLewis.rds')
#dfLewis<- readRDS('dfLewis.rds')
#write.table(dfLewis, file = 'dfLewis.csv', sep = ',', col.names=TRUE, row.names=FALSE)
#dfLewis<- read.csv ('dfLewis.csv', header = TRUE)
GRMS_vars <- c("Ob1", "Ob2", "Ob3", "Ob4", "Ob5", "Ob6", "Ob7", "Ob8", "Ob9", "Ob10", "Ma1", "Ma2", "Ma3", "Ma4", "Ma5", "Ma6", "Ma7", "St1", "St2", "St3", "St4", "St5", "An1", "An2", "An3")
Eng_vars <- c("Eng1", "Eng2")
dEng_vars <- c("dEng1", "dEng2")
MntlHlth_vars <- c("MH1", "MH2", "MH3", "MH4", "MH5", "MH6")
Cntrlty_vars <- c("Cntrlty1", "Cntrlty2", "Cntrlty3", "Cntrlty4", "Cntrlty5", "Cntrlty6", "Cntrlty7", "Cntrlty8", "Cntrlty9", "Cntrlty10")
dfLewis$GRMS <- sjstats::mean_n(dfLewis[, GRMS_vars], 0.80)
dfLewis$Engmt <- sjstats::mean_n(dfLewis[, Eng_vars], 0.80)
dfLewis$DisEngmt <- sjstats::mean_n(dfLewis[, dEng_vars], 0.80)
dfLewis$MntlHlth <- sjstats::mean_n(dfLewis[, MntlHlth_vars], 0.80)
dfLewis$Centrality <- sjstats::mean_n(dfLewis[, Cntrlty_vars], 0.80)
#If the scoring code above does not work for you, try the format below which involves inserting to periods in front of the variable list. One example is provided.
#dfLewis$GRMS <- sjstats::mean_n(dfLewis[, ..GRMS_vars], 0.80)
Lewis_df <- dplyr::select(dfLewis, GRMS, Centrality, DisEngmt, MntlHlth)
Lewis_table <- apaTables::apa.cor.table(Lewis_df, table.number = 1, show.sig.stars=TRUE, landscape=TRUE, filename="Lewis_Corr.doc")
print(Lewis_table)
library(psych)
psych::describe(Lewis_df)
#library(jtools) #the summ function creates a terrific regression table
#library(interactions)
#library(ggplot2)
Mod_a_path <- lm(DisEngmt~GRMS*Centrality, data=Lewis_df)
jtools::summ(Mod_a_path, digits = 3)
interactions::interact_plot(Mod_a_path, pred = GRMS, modx = Centrality) + ylim (1,4)
interactions::interact_plot(Mod_a_path, pred = Centrality, modx = GRMS) +ylim(1,4)
interactions::sim_slopes(Mod_a_path, pred = GRMS, modx = Centrality)
#sim_slopes(Mod_a_path, pred=GRIcntlty, modx = GRMS) #sometimes I like to look at it in reverse -- like in the plots
Mod_c_path <- lm(MntlHlth~GRMS*Centrality, data=Lewis_df)
jtools::summ(Mod_c_path, digits = 3)
interactions::interact_plot(Mod_c_path, pred = GRMS, modx = Centrality) + ylim(1,6)
#interactions::interact_plot(Mod_c_path, pred = GRIcntlty, modx = GRMS + ylim(1,6))
interactions::sim_slopes(Mod_c_path, pred = GRMS, modx = Centrality)
#sim_slopes(Mod_c_path, pred=GRIcntlty, modx = GRMS) #sometimes I like to look at it in reverse -- like in the plots
library(lavaan)
LMedModel <- '
MntlHlth ~ b*DisEngmt + c_p*GRMS
DisEngmt ~a*GRMS
#intercepts
DisEngmt ~ DisEngmt.mean*1
MntlHlth ~ MntlHlth.mean*1
indirect :=  a*b
direct  := c_p
total_c  := c_p + (a*b)
'
set.seed(230925) #required for reproducible results because lavaan introduces randomness into the calculations
LMed_fit <- lavaan::sem(LMedModel, data = Lewis_df, se="bootstrap", missing = 'fiml')
LMed_Sum <-  lavaan::summary(LMed_fit, standardized=T, rsq=T, ci=TRUE)
LMed_ParEsts<- lavaan::parameterEstimates(LMed_fit, boot.ci.type = "bca.simple", standardized=TRUE)
LMed_Sum
LMed_ParEsts
library(lavaan)
LMedModel <- '
MntlHlth ~ b*DisEngmt + c_p*GRMS
DisEngmt ~a*GRMS
#intercepts
DisEngmt ~ DisEngmt.mean*1
MntlHlth ~ MntlHlth.mean*1
indirect :=  a*b
direct  := c_p
total_c  := c_p + (a*b)
'
set.seed(230925) #required for reproducible results because lavaan introduces randomness into the calculations
LMed_fit <- lavaan::sem(LMedModel, data = Lewis_df, se="bootstrap", missing = 'fiml')
LMed_Sum <-  lavaan::summary(LMed_fit, standardized=T, rsq=T, ci=TRUE)
LMed_ParEsts<- lavaan::parameterEstimates(LMed_fit, boot.ci.type = "bca.simple", standardized=TRUE)
LMed_Sum
LMed_ParEsts
#only worked when I used the library to turn on all these pkgs
library(lavaan)
library(dplyr)
library(ggplot2)
library(tidySEM)
tidySEM::graph_sem(model = LMed_fit)
tidySEM::get_layout(LMed_fit)
Lmedmap <- tidySEM::get_layout("", "DisEngmt", "",
"GRMS", "", "MntlHlth",  rows=2)
Lmedmap
tidySEM::graph_sem(LMed_fit, layout=Lmedmap,  rect_width = 1.25, rect_height = 1.25, spacing_x = 2, spacing_y = 3, text_size = 4.5)
set.seed(230925)
Combined <- '
#equations
DisEngmt ~ a1*GRMS + a2*Centrality + a3*GRMS:Centrality
MntlHlth ~ c_p1*GRMS + c_p2*Centrality + c_p3*GRMS:Centrality + b*DisEngmt
#intercepts
DisEngmt ~ DisEngmt.mean*1
MntlHlth ~ MntlHlth.mean*1
#means, variances of W for simple slopes
Centrality ~ Centrality.mean*1
Centrality ~~ Centrality.var*Centrality
#index of moderated mediation, there will be an a and b path in the product
#if the a and/or b path is moderated, select the label that represents the moderation
imm := a3*b
#Note that we first create the indirect product, then add to it the product of the imm and the W level
indirect.SDbelow := a1*b + imm*(Centrality.mean - sqrt(Centrality.var))
indirect.mean := a1*b + imm*(Centrality.mean)
indirect.SDabove := a1*b + imm*(Centrality.mean + sqrt(Centrality.var))
#direct effect is also moderated so calculate with c_p1 + c_p3
direct.SDbelow := c_p1 + c_p3*(Centrality.mean - sqrt(Centrality.var))
direct.Smean := c_p1 + c_p3*(Centrality.mean)
direct.SDabove := c_p1 + c_p3*(Centrality.mean + sqrt(Centrality.var))
'
set.seed(230925) #required for reproducible results because lavaan introduces randomness into the calculations
Combined_fit <- lavaan::sem(Combined, data = Lewis_df, se = "bootstrap", missing = 'fiml', bootstrap = 1000)
cFITsum <- lavaan::summary(Combined_fit, standardized = TRUE, rsq=T, ci=TRUE)
cParamEsts <- lavaan::parameterEstimates(Combined_fit, boot.ci.type = "bca.simple", standardized=TRUE)
cFITsum
cParamEsts
#only worked when I used the library to turn on all these pkgs
library(lavaan)
library(dplyr)
library(ggplot2)
library(tidySEM)
tidySEM::graph_sem(model = Combined_fit)
#only worked when I used the library to turn on all these pkgs
library(lavaan)
library(dplyr)
library(ggplot2)
library(tidySEM)
tidySEM::graph_sem(model = Combined_fit)
tidySEM::get_layout(Combined_fit)
comb_map <- tidySEM::get_layout("", "DisEngmt", "",
"GRMS", "", "MntlHlth",
"Centrality", "","",
"", "GRMS:Centrality","", rows=4)
comb_map
tidySEM::graph_sem(Combined_fit, layout=comb_map,  rect_width = 1.25, rect_height = 1.25, spacing_x = 2, spacing_y = 3, text_size = 3.5)
write.csv(cParamEsts, file="Combined_fit.csv") #optional to write it to a .csv file
interactions::interact_plot(Mod_c_path, pred = GRMS, modx = Centrality) + ylim(1,6)
#interactions::interact_plot(Mod_c_path, pred = GRIcntlty, modx = GRMS + ylim(1,6))
raw <- readRDS("ReC.rds")
View(raw)
raw <-(dplyr::filter(raw, Course == "Multivariate"))
TradPed_vars <- c('ClearResponsibilities', 'EffectiveAnswers','Feedback', 'ClearOrganization','ClearPresentation')
raw$TradPed <- sjstats::mean_n(raw[, ..TradPed_vars], .75)
Valued_vars <- c('ValObjectives', 'IncrUnderstanding','IncrInterest')
raw$Valued <- sjstats::mean_n(raw[, ..Valued_vars], .75)
SRPed_vars <- c('InclusvClassrm','EquitableEval', 'MultPerspectives', 'DEIintegration')
raw$SRPed <- sjstats::mean_n(raw[,..SRPed_vars], .75)
babydf <- dplyr::select(raw, Centering, TradPed, SRPed, Valued)
str(babydf)
babydf$CENTERING <- as.numeric(babydf$Centering)
babydf$CENTERING <- (babydf$CENTERING - 1)
str(babydf)
View(babydf)
psych::pairs.panels(babydf)
mod_a_path <- lm(SRPed~Centering*TradPed, data=babydf)
#the base R output if you prefer this view
summary(mod_a_path)
interactions::sim_slopes(mod_a_path, pred = TradPed, modx = Centering)
#sim_slopes(Mod_a_path, pred=GRIcntlty, modx = GRMS) #sometimes I like to look at it in reverse -- like in the plots
set.seed(230925)
ModMedOnA <- '
#equations
SRPed ~ a1*CENTERING + a2*TradPed + a3*CENTERING:TradPed
Valued ~ c_p*CENTERING + b*SRPed
#intercepts
SRPed ~ SRPed.mean*1
Valued ~ Valued.mean*1
#means, variances of W for simple slopes
TradPed ~ TradPed.mean*1
TradPed ~~ TradPed.var*TradPed
#index of moderated mediation, there will be an a and b path in the product
#if the a and/or b path is moderated, select the label that represents the moderation
imm := a3*b
#Note that we first create the indirect product, then add to it the product of the imm and the W level
indirect.SDbelow := a1*b + imm*(TradPed.mean - sqrt(TradPed.var))
indirect.mean := a1*b + imm*(TradPed.mean)
indirect.SDabove := a1*b + imm*(TradPed.mean + sqrt(TradPed.var))
'
set.seed(230925) #required for reproducible results because lavaan introduces randomness into the calculations
ModMedOnA_fit <- lavaan::sem(ModMedOnA, data =babydf, se = "bootstrap", missing = 'fiml', bootstrap = 1000)
ModMedOnAsum <- lavaan::summary(ModMedOnA_fit, standardized = TRUE, rsq=T, ci=TRUE)
ModMedOnAParamEsts <- lavaan::parameterEstimates(ModMedOnA_fit, boot.ci.type = "bca.simple", standardized=TRUE)
ModMedOnAsum
ModMedOnAParamEsts
#only worked when I used the library to turn on all these pkgs
library(lavaan)
library(dplyr)
library(ggplot2)
library(tidySEM)
tidySEM::graph_sem(model = ModMedOnA_fit)
tidySEM::get_layout(ModMedOnA_fit)
comb_map <- tidySEM::get_layout("", "SRPed", "",
"CENTERING", "", "Valued",
"TradPed", "","",
"", "CENTERING:TradPed","", rows=4)
comb_map
tidySEM::graph_sem(ModMedOnA_fit, layout=comb_map,  rect_width = 1.5, rect_height = 1.25, spacing_x = 2, spacing_y = 3, text_size = 3.5)
write.csv (ModMedOnAParamEsts, file="ModMedOnAParamEsts.csv") #optional to write it to a .csv file
write.csv (ModMedOnAParamEsts, file="ModMedOnAParamEsts.csv") #optional to write it to a .csv file
write.csv (ModMedOnAParamEsts, file="ModMedOnAParamEsts.csv") #optional to write it to a .csv file
raw <- readRDS("ReC.rds")
raw <-(dplyr::filter(raw, Course == "Multivariate"))
TradPed_vars <- c('ClearResponsibilities', 'EffectiveAnswers','Feedback', 'ClearOrganization','ClearPresentation')
raw$TradPed <- sjstats::mean_n(raw[, ..TradPed_vars], .75)
Valued_vars <- c('ValObjectives', 'IncrUnderstanding','IncrInterest')
raw$Valued <- sjstats::mean_n(raw[, ..Valued_vars], .75)
SRPed_vars <- c('InclusvClassrm','EquitableEval', 'MultPerspectives', 'DEIintegration')
raw$SRPed <- sjstats::mean_n(raw[,..SRPed_vars], .75)
babydf <- dplyr::select(raw, Centering, TradPed, SRPed, Valued)
str(babydf)
babydf$CENTERING <- as.numeric(babydf$Centering)
babydf$CENTERING <- (babydf$CENTERING - 1)
str(babydf)
psych::pairs.panels(babydf)
Mod_b_path <- lm(Valued~SRPed*TradPed, data=babydf)
#the base R output if you prefer this view
summary(Mod_b_path)
#library(jtools) #the summ function creates a terrific regression table
#library(interactions)
library(ggplot2)
jtools::summ(Mod_b_path, digits = 3)
interactions::interact_plot(Mod_b_path, pred = SRPed, modx = TradPed) + ylim (1,5)
interactions::sim_slopes(Mod_b_path, pred = SRPed, modx = TradPed)
#interactions::sim_slopes(Mod_b_path, pred=TradPed, modx = SRPed) #sometimes I like to look at it in reverse -- like in the plots
library(lavaan)
medmodel <- '
Valued ~ b*SRPed + c_p*CENTERING
SRPed ~a*CENTERING
#intercepts
CENTERING ~ CENTERING.mean*1
Valued ~ Valued.mean*1
indirect :=  a*b
direct  := c_p
total_c  := c_p + (a*b)
'
set.seed(230925) #required for reproducible results because lavaan introduces randomness into the calculations
medmodel_fit <- lavaan::sem(medmodel, data = babydf, se="bootstrap", missing = 'fiml')
medmodel_Sum <-  lavaan::summary(medmodel_fit, standardized=T, rsq=T, ci=TRUE)
medmodel_ParEsts<- lavaan::parameterEstimates(medmodel_fit, boot.ci.type = "bca.simple", standardized=TRUE)
medmodel_Sum
medmodel_ParEsts
#only worked when I used the library to turn on all these pkgs
library(lavaan)
library(dplyr)
library(ggplot2)
library(tidySEM)
tidySEM::graph_sem(model = medmodel_fit)
tidySEM::get_layout(medmodel_fit)
medmap <- tidySEM::get_layout("", "SRPed", "",
"CENTERING", "", "Valued",  rows=2)
medmap
tidySEM::graph_sem(medmodel_fit, layout=medmap,  rect_width = 1.25, rect_height = 1.25, spacing_x = 2, spacing_y = 3, text_size = 4.5)
set.seed(230925)
ModMedOnB <- '
#equations
SRPed ~ a*CENTERING
Valued ~ cp*CENTERING + b1*SRPed + b2*TradPed + b3*SRPed:TradPed
#intercepts
SRPed ~ SRPed.mean*1
Valued ~ Valued.mean*1
#means, variances of W for simple slopes
TradPed ~ TradPed.mean*1
TradPed ~~ TradPed.var*TradPed
#index of moderated mediation, there will be an a and b path in the product
#if the a and/or b path is moderated, select the label that represents the moderation
imm := a*b3
#Note that we first create the indirect product, then add to it the product of the imm and the W level
indirect.SDbelow := a*b1 + imm*(TradPed.mean - sqrt(TradPed.var))
indirect.mean := a*b1 + imm*(TradPed.mean)
indirect.SDabove := a*b1 + imm*(TradPed.mean + sqrt(TradPed.var))
'
set.seed(230925) #required for reproducible results because lavaan introduces randomness into the calculations
ModMedOnB_fit <- lavaan::sem(ModMedOnB, data =babydf, se = "bootstrap", missing = 'fiml', bootstrap = 1000)
ModMedOnBsum <- lavaan::summary(ModMedOnB_fit, standardized = TRUE, rsq=T, ci=TRUE)
ModMedOnBParamEsts <- lavaan::parameterEstimates(ModMedOnB_fit, boot.ci.type = "bca.simple", standardized=TRUE)
ModMedOnBsum
ModMedOnBParamEsts
#only worked when I used the library to turn on all these pkgs
library(lavaan)
library(dplyr)
library(ggplot2)
library(tidySEM)
tidySEM::graph_sem(model = ModMedOnB_fit)
tidySEM::get_layout(ModMedOnB_fit)
comb_map <- tidySEM::get_layout("", "SRPed", "TradPed", "SRPed:TradPed",
"CENTERING", "", "Valued", "", rows=2)
comb_map
tidySEM::graph_sem(ModMedOnB_fit, layout=comb_map,  rect_width = 1.25, rect_height = 1.25, spacing_x = 2, spacing_y = 3, text_size = 3.5)
write.csv (ModMedOnBParamEsts, file="ModMedOnBParamEsts.csv") #optional to write it to a .csv file
interactions::interact_plot(Mod_b_path, pred = SRPed, modx = TradPed) + ylim(1,5)
#interactions::interact_plot(Mod_c_path, pred = TradPed, modx = SRPed + ylim(1,5))
raw <- readRDS("ReC.rds")
View(raw)
raw <-(dplyr::filter(raw, Course == "Multivariate"))
TradPed_vars <- c('ClearResponsibilities', 'EffectiveAnswers','Feedback', 'ClearOrganization','ClearPresentation')
raw$TradPed <- sjstats::mean_n(raw[, ..TradPed_vars], .75)
Valued_vars <- c('ValObjectives', 'IncrUnderstanding','IncrInterest')
raw$Valued <- sjstats::mean_n(raw[, ..Valued_vars], .75)
SRPed_vars <- c('InclusvClassrm','EquitableEval', 'MultPerspectives', 'DEIintegration')
raw$SRPed <- sjstats::mean_n(raw[,..SRPed_vars], .75)
View(raw)
babydf <- dplyr::select(raw, Centering, TradPed, SRPed, Valued)
View(babydf)
str(babydf)
babydf$CENTERING <- as.numeric(babydf$Centering)
babydf$CENTERING <- (babydf$CENTERING - 1)
str(babydf)
psych::pairs.panels(babydf)
Mod_b_path <- lm(Valued~SRPed*TradPed, data=babydf)
#the base R output if you prefer this view
summary(Mod_b_path)
#library(jtools) #the summ function creates a terrific regression table
#library(interactions)
library(ggplot2)
jtools::summ(Mod_b_path, digits = 3)
interactions::interact_plot(Mod_b_path, pred = SRPed, modx = TradPed) + ylim (1,5)
interactions::sim_slopes(Mod_b_path, pred = SRPed, modx = TradPed)
#interactions::sim_slopes(Mod_b_path, pred=TradPed, modx = SRPed) #sometimes I like to look at it in reverse -- like in the plots
library(lavaan)
medmodel <- '
Valued ~ b*SRPed + c_p*CENTERING
SRPed ~a*CENTERING
#intercepts
CENTERING ~ CENTERING.mean*1
Valued ~ Valued.mean*1
indirect :=  a*b
direct  := c_p
total_c  := c_p + (a*b)
'
set.seed(230925) #required for reproducible results because lavaan introduces randomness into the calculations
medmodel_fit <- lavaan::sem(medmodel, data = babydf, se="bootstrap", missing = 'fiml')
medmodel_Sum <-  lavaan::summary(medmodel_fit, standardized=T, rsq=T, ci=TRUE)
medmodel_ParEsts<- lavaan::parameterEstimates(medmodel_fit, boot.ci.type = "bca.simple", standardized=TRUE)
medmodel_Sum
medmodel_ParEsts
#only worked when I used the library to turn on all these pkgs
library(lavaan)
library(dplyr)
library(ggplot2)
library(tidySEM)
tidySEM::graph_sem(model = medmodel_fit)
tidySEM::get_layout(medmodel_fit)
medmap <- tidySEM::get_layout("", "SRPed", "",
"CENTERING", "", "Valued",  rows=2)
medmap
tidySEM::graph_sem(medmodel_fit, layout=medmap,  rect_width = 1.25, rect_height = 1.25, spacing_x = 2, spacing_y = 3, text_size = 4.5)
set.seed(230925)
ModMedOnB <- '
#equations
SRPed ~ a*CENTERING
Valued ~ cp*CENTERING + b1*SRPed + b2*TradPed + b3*SRPed:TradPed
#intercepts
SRPed ~ SRPed.mean*1
Valued ~ Valued.mean*1
#means, variances of W for simple slopes
TradPed ~ TradPed.mean*1
TradPed ~~ TradPed.var*TradPed
#index of moderated mediation, there will be an a and b path in the product
#if the a and/or b path is moderated, select the label that represents the moderation
imm := a*b3
#Note that we first create the indirect product, then add to it the product of the imm and the W level
indirect.SDbelow := a*b1 + imm*(TradPed.mean - sqrt(TradPed.var))
indirect.mean := a*b1 + imm*(TradPed.mean)
indirect.SDabove := a*b1 + imm*(TradPed.mean + sqrt(TradPed.var))
'
set.seed(230925) #required for reproducible results because lavaan introduces randomness into the calculations
ModMedOnB_fit <- lavaan::sem(ModMedOnB, data =babydf, se = "bootstrap", missing = 'fiml', bootstrap = 1000)
ModMedOnBsum <- lavaan::summary(ModMedOnB_fit, standardized = TRUE, rsq=T, ci=TRUE)
ModMedOnBParamEsts <- lavaan::parameterEstimates(ModMedOnB_fit, boot.ci.type = "bca.simple", standardized=TRUE)
ModMedOnBsum
ModMedOnBParamEsts
#only worked when I used the library to turn on all these pkgs
library(lavaan)
library(dplyr)
library(ggplot2)
library(tidySEM)
tidySEM::graph_sem(model = ModMedOnB_fit)
tidySEM::get_layout(ModMedOnB_fit)
comb_map <- tidySEM::get_layout("", "SRPed", "TradPed", "SRPed:TradPed",
"CENTERING", "", "Valued", "", rows=2)
comb_map
tidySEM::graph_sem(ModMedOnB_fit, layout=comb_map,  rect_width = 1.25, rect_height = 1.25, spacing_x = 2, spacing_y = 3, text_size = 3.5)
write.csv (ModMedOnBParamEsts, file="ModMedOnBParamEsts.csv") #optional to write it to a .csv file
interactions::interact_plot(Mod_b_path, pred = SRPed, modx = TradPed) + ylim(1,5)
#interactions::interact_plot(Mod_c_path, pred = TradPed, modx = SRPed + ylim(1,5))
citr:::insert_citation()
