citr:::insert_citation()
citr:::insert_citation()
#Entering the intercorrelations, means, and standard deviations from the journal article
mu <- c(.34, 3.00, 2.98, 2.36, 3.50, 1.64)
sd <- c(.16, .83, .99, .90, .90, .53)
r_mat <- matrix (c(1,   .59, .26,   .34,  -.25, -.02,
.59, 1.00, .12,   .19,  -.28, .00,
.26,  .12, 1.00, .66,  -.55, .07,
.34,  .19, .66,  1.00, -.66, .05,
-.25, -.28, -.55,-.66,  1.00, .08,
-.02,  .00,  .07, .05, .08,  1), ncol = 6)
#Creating a covariance matrix
cov_mat <- sd %*% t(sd) * r_mat
#Set random seed so that the following matrix always gets the same results.
set.seed(210409)
library(MASS)
Kim_df <- mvrnorm(n = 156, mu=mu, Sigma = cov_mat, empirical = TRUE)
#renaming the variables
as.data.frame(Kim_df, row.names = NULL, optional = FALSE, make.names = TRUE)
library(tidyverse)
Kim_df <- Kim_df%>%
as.data.frame %>%
rename(REMS = V1, CMI = V2, ANX = V3, DEP = V4, PWB = V5, HlpSk = V6)
#Checking our work against the original correlation matrix
#round(cor(Kim_df),3)
View(Kim_df)
library(apaTables)
apa.cor.table(Kim_df)
# to write it to a word file, add this to the script:  filename = "ex.CorTable1.doc"
library(psych)
psych::pairs.panels(Kim_df)
library(jtools) #the summ function creates a terrific regression table
library(interactions)
library(ggplot2)
KimSimpMod <- lm(ANX~REMS*HlpSk, data=Kim_df)
#summary(KimSimpMod)
KimSimpMod_summ <- summ(KimSimpMod, digits = 3)
KimSimpMod_summ
interact_plot(KimSimpMod, pred = HlpSk, modx = REMS)
interact_plot(KimSimpMod, pred = REMS, modx = HlpSk)
sim_slopes(KimSimpMod, pred = REMS, modx = HlpSk)
#sim_slopes(KimSimpMod, pred=GRIcntlty, modx = GRMS) #sometimes I like to look at it in reverse -- like in the plots
library(lavaan)
set.seed(210501)
KimSimpModMLE <- '
ANX ~ b1*REMS + b2*HlpSk + b3*REMS:HlpSk
#intercept (constant) of ANX
ANX ~ ANX.mean*1
#mean of W (HlpSk, in this case) for use in simple slopes
HlpSk ~ HlpSk.mean*1
#variance of W (age, in this case) for use in simple slopes
HlpSk ~~HlpSk.var*HlpSk
#simple slopes
SD.below := b1 + b3*(HlpSk.mean - sqrt(HlpSk.var))
mean := b1 + b3*(HlpSk.mean)
SD.above := b1 + b3*(HlpSk.mean + sqrt(HlpSk.var))
'
kMLE_fit <- sem(KimSimpModMLE, data = Kim_df, missing = 'fiml', se = "bootstrap", bootstrap = 1000)
k1summary <- summary(kMLE_fit, standardized = TRUE, rsq=T, ci=TRUE)
k1ParamEsts <- parameterEstimates(kMLE_fit, boot.ci.type = "bca.simple", standardized=TRUE)
k1summary
k1ParamEsts
library(semPlot)
semPaths(kMLE_fit, #must identify the model you want to map
what = "est", #"est" plots the estimates, but keeps it greyscale with no fading
#whatLabels = "stand", #"stand" changes to standardized values
layout = 'tree', rotation = 2, #together, puts predictors on left, IVs on right
#layout = 'circle',
edge.label.cex = 1.00, #font size of parameter values
#edge.color = "black", #overwrites the green/black coloring
sizeMan=10, #size of squares/observed/"manifest" variables
fade=FALSE, #if TRUE, there lines are faded such that weaker lines correspond with lower values -- a cool effect, but tough for journals
esize=2,
asize=3,
#label.prop = .5,
label.font = 2.5, #controls size (I think) of font for labels
label.scale = TRUE, #if false, the labels will not scale to fit inside the nodes
nDigits = 3, #decimal places (default is 2)
residuals = FALSE,#excludes residuals (and variances) from the path diagram
nCharNodes = 0, #specifies how many characters to abbreviate variable lables; default is 3.  If 0, uses your entire variable label and adjusts fontsize (which could be a downside)
intercepts = FALSE, #gets rid of those annoying triangles (intercepts) in the path diagram)
)
title("Help Seeking as a Moderator in the Relationship between REMS and ANX")
library(formattable) #to use the digits function
#VALUES FOR lm() OUTPUT
k1RYicpt <- digits(summary(KimSimpMod)$coefficients [1,1],3) #B weight for intercept
k1RYicpt
k1RYicpt_se <- digits(summary(KimSimpMod)$coefficients [1,2],3) #SE for intercept
k1RYicpt_se
k1RYicpt_p <- digits(summary(KimSimpMod)$coefficients [1, 4], 3)#p value for the intercept
k1RYicpt_p
k1RYb1 <- digits(summary(KimSimpMod)$coefficients [2,1],3) #B weight for X
k1RYb1
k1RYb1_se <- digits(summary(KimSimpMod)$coefficients [2,2],3) #SE for X
k1RYb1_se
k1RYb1_p <- digits(summary(KimSimpMod)$coefficients [2, 4], 3)#p value for X
k1RYb1_p
k1RYb2 <- digits(summary(KimSimpMod)$coefficients [3,1],3) #B weight for W
k1RYb2
k1RYb2_se <- digits(summary(KimSimpMod)$coefficients [3,2],3) #SE for W
k1RYb2_se
k1RYb2_p <- digits(summary(KimSimpMod)$coefficients [3, 4], 3)#p value for W
k1RYb2_p
k1RYb3 <- digits(summary(KimSimpMod)$coefficients [4,1],3) #B weight for XW
k1RYb3
k1RYb3_se <- digits(summary(KimSimpMod)$coefficients [4,2],3) #SE for XW
k1RYb3_se
k1RYb3_p <- digits(summary(KimSimpMod)$coefficients [4, 4], 3)#p value for XW
k1RYb3_p
k1R_rsqY <- digits(summary(KimSimpMod)$coefficients [4, 4], 3)#p value for XW
k1R_rsqY
k1R_Rsq <- percent(summary(KimSimpMod)$r.squared)
k1R_Rsq
#VALUES FOR LAVAAN OUTPUT
# Values for the intercept of the IV
k1Yicpt <- digits(k1ParamEsts$est[4], 3) #B weight for the intercept
k1Yicpt
k1Yicpt_SE <- digits(k1ParamEsts$se[4], 3)#p value for the intercept
k1Yicpt_SE
k1Yicpt_p <- digits(k1ParamEsts$pvalue[4], 3)#p value for the intercept
k1Yicpt_p
k1b1 <- digits(k1ParamEsts$est[1], 3) #B weight for the IV
k1b1
k1b1_SE <- digits(k1ParamEsts$se[1], 3)#p value for  the IV
k1b1_SE
k1b1_p <- digits(k1ParamEsts$pvalue[1], 3)#p value for  the IV
k1b1_p
k1b2 <- digits(k1ParamEsts$est[2], 3) #B weight for the moderator
k1b2
k1b2_SE <- digits(k1ParamEsts$se[2], 3)#p value for the moderator
k1b2_SE
k1b2_p <- digits(k1ParamEsts$pvalue[2], 3)#p value for the moderator
k1b2_p
k1b3 <- digits(k1ParamEsts$est[3], 3) #B weight for the interaction effect
k1b3
k1b3_SE <- digits(k1ParamEsts$se[3], 3)#p value for the interaction effect
k1b3_SE
k1b3_p <- digits(k1ParamEsts$pvalue[3], 3)#p value for the interaction effect
k1b3_p
# Proportion of variance accounted for
k1Rsq_Y <- percent(k1summary$PE$est[16])
k1Rsq_Y
